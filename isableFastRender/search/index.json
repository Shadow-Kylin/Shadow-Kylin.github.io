[{"content":"In Git, files usually have four statuses: untracked, unmodified, modified and staged.\nUntracked and modified files reside in the working directory, while staged files situated in the staging area, and unmodified files are stored in the .git directory (repository). The unmodified files is actually the committed files.\nThe git clean command eliminates all untracked files and provides three flags or switches to define which untracked files to remove:\n-f flag obliges the removal of all untracked files, excluding directories and ignored files. -d flag obliges the removal of untracked directories. -x flag eliminates untracked files corresponding to .gitignore files. We can clear untracked files with the following command:\n1 2 3 $ git clean -df Removing test.txt Removing test/ The -df option ensures that removal is forced and that untracked directories are also included for removal.\n1 2 $ git clean fatal: clean.requireForce defaults to true and neither -i, -n, nor -f given; refusing to clean git clean needs to be forced.\n","date":"2023-10-16T00:00:00Z","permalink":"http://localhost:1313/p/gitdiscard-untracked-files/","title":"【Git】Discard Untracked Files"},{"content":"Prop大小写 Prop的命名规则有camelCase，驼峰命名和kebab-case，短横线分隔。\n由于HTML对大小写不敏感，所以浏览器会把大写字母解释为小写字母。\n当我们使用camelCase命名prop时，在Dom中的template模板使用该prop就需要换成对应的kebab-case命名形式。\n如果在字符串模板中使用，该限制就不存在。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- kebab-case in HTML --\u0026gt; \u0026lt;blog-post post-title=\u0026#34;hello1\u0026#34;\u0026gt;\u0026lt;/blog-post\u0026gt; \u0026lt;profile\u0026gt;\u0026lt;/profile\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;blog-post\u0026#39;, { // camelCase in JavaScript props: [\u0026#39;postTitle\u0026#39;], template: \u0026#39;\u0026lt;h3\u0026gt;{{ postTitle }}\u0026lt;/h3\u0026gt;\u0026#39; }); Vue.component(\u0026#39;profile\u0026#39;,{ template:`\u0026lt;blog-post postTitle=\u0026#34;hello2\u0026#34;\u0026gt;\u0026lt;/blog-post\u0026gt;` }); new Vue({ el: \u0026#39;#app\u0026#39; }); \u0026lt;/script\u0026gt; Prop类型 props可以简单地写为一个数组，但也可以使用对象的形式为每个prop指定其类型：\n1 2 3 4 5 6 7 8 9 props: { title: String, likes: Number, isPublished: Boolean, commentIds: Array, author: Object, callback: Function, contactsPromise: Promise // or any other constructor } 传递静态或动态的Prop 静态传递prop：\n1 \u0026lt;blog-post title=\u0026#34;My journey with Vue\u0026#34;\u0026gt;\u0026lt;/blog-post\u0026gt; 使用v-bind动态传递prop：\n1 2 3 4 5 6 7 \u0026lt;!-- Dynamically assign the value of a variable --\u0026gt; \u0026lt;blog-post v-bind:title=\u0026#34;post.title\u0026#34;\u0026gt;\u0026lt;/blog-post\u0026gt; \u0026lt;!-- Dynamically assign the value of a complex expression --\u0026gt; \u0026lt;blog-post v-bind:title=\u0026#34;post.title + \u0026#39; by \u0026#39; + post.author.name\u0026#34; \u0026gt;\u0026lt;/blog-post\u0026gt; 上述示例的post.title是字符串类型，但是我们也可以传递任何类型。\n如果我们使用比如Number、Boolean、Array、Object等类型的原始值作为prop，怎么避免它们被当成字符串传递呢？使用v-bind即可。\n特殊的，如果我们想要传递一个对象的所有prop而非对象本身，可以使用不带参数的v-bind：\n1 \u0026lt;blog-post v-bind=\u0026#34;post\u0026#34;\u0026gt;\u0026lt;/blog-post\u0026gt; 等价于：\n1 2 3 4 \u0026lt;blog-post v-bind:id=\u0026#34;post.id\u0026#34; v-bind:title=\u0026#34;post.title\u0026#34; \u0026gt;\u0026lt;/blog-post\u0026gt; 单向数据流 数据通过prop的传递是单向的，只能从父组件传递到子组件，而无法反向传递。如果没有这种限制，那么我们就很难掌控数据流的流向。\n父组件prop的更新也会刷新传递给子组件的prop。\n一旦我们尝试修改父组件传递给子组件的prop，Vue会在浏览器控制台发出警告。\n子组件中有两种常见的需要修改传递来的prop的情况：\n用来初始化本地的prop\n1 2 3 4 5 6 props: [\u0026#39;initialCounter\u0026#39;], data: function () { return { counter: this.initialCounter } } 需要修改传递来的prop\n1 2 3 4 5 6 props: [\u0026#39;size\u0026#39;], computed: { normalizedSize: function () { return this.size.trim().toLowerCase() } } 要小心使用传递来的Object或Array类型的prop，因为会不小心修改了原数据。我们可以进行深拷贝来避免这种情况。\nProp验证 基础的类型检查 null和undefined会通过任何类型验证。\n1 2 3 props:{ propA: Number } 多个可能的类型 1 2 3 props:{ propB: [String, Number], } 必填项 1 2 3 4 5 6 props:{ propc:{ type: String, required: true } } 默认值 1 2 3 4 5 6 7 8 9 10 11 12 13 props:{ propD: { type: Number, default: 100 }, propE: { type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () { return { message: \u0026#39;hello\u0026#39; } } }, } 自定义验证函数 1 2 3 4 5 6 7 8 props: { propF: { validator: function (value) { // 这个值必须匹配下列字符串中的一个 return [\u0026#39;success\u0026#39;, \u0026#39;warning\u0026#39;, \u0026#39;danger\u0026#39;].includes(value) } } } prop会在组件实例创建前进行验证，开发环境构建版本的Vue验证prop失败会给出浏览器控制台警告。\n类型检查 type的值可以是以下原生构造函数之一：\nString Number Boolean Array Object Date Function Symbol type也可以使用自定义的构造函数：\n1 2 3 4 5 6 7 8 9 function Person (firstName, lastName) { this.firstName = firstName this.lastName = lastName } Vue.component(\u0026#39;blog-post\u0026#39;, { props: { author: Person } }) Non-Prop Attributes non-prop attributes是指传递给了一个组件但是该组件中没有相关定义的prop，现在叫做attributes。\n一些第三方组件的设计者只会定义那些组件所必需的、常见的的prop，而其他需要额外的prop的场景就会使用non-prop attribute，这些额外的attribute会被添加到组件的root element。\n替换/合并已有的Attributes 通常传递给子组件的attributes会替换其已经设置好了的值，但是class和style attributes将会被合并处理。\n禁用Attributes继承 我们可以设置inheritAttrs: false来阻止组件的根元素继承attributes。\n1 2 3 4 Vue.component(\u0026#39;my-component\u0026#39;, { inheritAttrs: false, // ... }) 接下来可以使用$attrs来获取传递给组件的所有attribute（除了class和style）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Vue.component(\u0026#39;base-input\u0026#39;, { inheritAttrs: false, props: [\u0026#39;label\u0026#39;, \u0026#39;value\u0026#39;], template: ` \u0026lt;label\u0026gt; {{ label }} \u0026lt;input v-bind=\u0026#34;$attrs\u0026#34; v-bind:value=\u0026#34;value\u0026#34; v-on:input=\u0026#34;$emit(\u0026#39;input\u0026#39;, $event.target.value)\u0026#34; \u0026gt; \u0026lt;/label\u0026gt; ` }) 1 2 3 4 5 6 \u0026lt;base-input label=\u0026#34;Username:\u0026#34; v-model=\u0026#34;username\u0026#34; required placeholder=\u0026#34;Enter your username\u0026#34; \u0026gt;\u0026lt;/base-input\u0026gt; 上面示例的placeholder作为non-prop attribute传递，但是我们禁用了组件根元素继承attributes，然后通过v-bind=\u0026quot;$attrs\u0026quot;将class和style以外的attributes传递给了base-input。\n参考资料 Props-Vue 2 vm.$attrs ","date":"2023-10-14T00:00:00Z","permalink":"http://localhost:1313/p/vue-2props/","title":"【Vue 2】Props"},{"content":"前言 在 JavaScript 中，null 和 undefined 是两个特殊的值，它们表示着不同的含义，但在某些情况下会引起混淆。\nnull null是Null类型的唯一值，是一个假值，表示一个空对象指针，即不存在的对象，这也是我们使用typeof判断null时返回Object的原因。\n1 console.log(typeof null); //object 当你声明一个变量但不给它赋值时，它的默认值是 undefined，但你也可以明确将其赋值为 null，表示该变量的值为空。\nnull 通常用于明确指示一个变量没有值，或者用于重置对象的引用，以便后续垃圾回收。\nnull 的判断 假值有很多，我们不能通过下面类型代码判断一个变量是不是null：\n1 2 3 4 5 if (!null) { console.log(\u0026#39;null is false value\u0026#39;) }else{ console.log(\u0026#39;null is true value\u0026#39;) } 那怎么判断是不是null呢？\n1.使用严格相等运算符 ===\n使用===全等号而不是等于号==，因为 javascript 认为null==undefined成立。\n1 2 3 4 5 6 const value=null if(value===null){ //值为null }else{ //值不为null } 2.使用 Object.is()\nObject.is() 用于比较两个值是否相等，与 === 行为类似，但它对于一些边界情况的处理更为人性化。\n1 2 3 4 5 6 7 8 console.log(NaN === NaN); // 输出 false console.log(Object.is(NaN, NaN)); // 输出 true console.log(-0 === 0); // 输出 true console.log(Object.is(-0, 0)); // 输出 false console.log(+0 === -0); // 输出 true console.log(Object.is(+0, -0)); // 输出 false var abc = null; console.log(Object.is(abc, null)); //true undefined undefined也是Undefined类型的唯一值，也是一个假值，在我们声明变量但没初始化（赋值）时，变量自动赋值为undefined。当然，值为undefined的已声明变量 和 未定义变量 还是有区别的，如下：\n1 2 3 let a; console.log(a)\t//undefined console.log(b)\t//未定义变量报错 此外，undefined 也表示一个对象属性不存在的情况。如果你尝试访问对象中不存在的属性，将返回 undefined。\n如果函数的参数没有传递值，它们的默认值是 undefined，而不是 null。\nundefined 的判断 1.使用严格相等运算符 ===\n1 2 3 4 var abc; if (abc === undefined) { console.log(\u0026#34;值为 undefined\u0026#34;); } 2.使用类型比较运算符 typeof\n1 2 3 4 var abc; if (typeof abc === \u0026#34;undefined\u0026#34;) { console.log(\u0026#34;值为 undefined\u0026#34;); } 3.使用 Object.is()\n1 2 3 4 var abc; if (Object.is(abc,undefined)) { console.log(\u0026#34;值为 undefined\u0026#34;); } 有点特别的是，使用typeof判断值为undefined的已声明变量 和 未定义变量的结果都为undefined。这是由于两者在使用价值上是相同的，都是没有实际使用价值。\n1 2 3 var abc; console.log(typeof abc); //undefined console.log(typeof efg); //undefined 最后，使用方面，我们不必显示赋值为undefined，但可以在需要的时候赋值为null。\n","date":"2023-10-10T00:00:00Z","permalink":"http://localhost:1313/p/javascriptnull%E5%92%8Cundefined/","title":"【JavaScript】null和undefined"},{"content":"同步与异步的概念 JavaScript 是一门单线程的语言，这意味着它在任何给定的时间只能执行一个任务。\n然而，JavaScript 通过异步编程技术来处理并发操作，以避免阻塞主线程的情况。\n在上图中，同步行为的进程 A 因为等待进程 B 执行完而被阻塞了一段时间。异步行为的进程 A 则会继续执行，等到进程 B 有了结果，它再告知进程 A 来处理。\n异步行为是为了优化计算量大而耗时长的操作，但也并非只能处理该类情况，只要需要执行某个异步操作且不想主线程被阻塞，那么都可以使用异步编程。异步行为类似于系统中断。\n同步行为对应内存中顺序执行的处理器指令，指令执行完后就容易推断出程序的状态，每个操作都是可预测性的。\n设计一个这样的异步系统是困难的，因为你不知道异步结果什么时候可以获取。\nJavaScript 最初的异步编程方式：回调 使用回调作为异步编程的方式：回调函数作为另一个函数的参数，并在某个事件发送或异步操作完成后执行。\n1 2 3 4 5 6 7 8 9 function fetchData(callback){ setTimeout(function(){ callback(\u0026#39;Data fetched\u0026#39;); },1000); } fetchData(function(result){ console.log(result); }); 加上对失败回调的处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function fetchData(successCallback, errorCallback) { setTimeout(function () { // 模拟一个错误，你可以根据具体情况处理错误 const error = null; // 这里假设没有错误 if (error) { errorCallback(error); // 调用失败回调函数并传递错误 } else { successCallback(\u0026#39;Data fetched\u0026#39;); // 调用成功回调函数并传递数据 } }, 1000); } // 使用 fetchData 函数 fetchData( function (data) { console.log(\u0026#39;Success:\u0026#39;, data); }, function (error) { console.error(\u0026#39;Error:\u0026#39;, error); } ); 这种模式有很多弊端：首先需要在指定时间内才能得到异步函数的返回值，其次需要提前定义好回调函数。\n最后，多个异步操作嵌套在一起，会形成回调地狱。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 function fetchData(callback) { setTimeout(function () { callback(\u0026#34;Data fetched\u0026#34;); }, 1000); } function processData(data, successCallback, errorCallback) { setTimeout(function () { // 模拟一个错误 const error = null; // 这里假设没有错误 if (error) { errorCallback(error); } else { successCallback(\u0026#34;Data processed\u0026#34;); } }, 1000); } function saveData(data, successCallback, errorCallback) { setTimeout(function () { // 模拟一个错误 const error = new Error(\u0026#34;Save failed\u0026#34;); errorCallback(error); }, 1000); } fetchData(function (data) { processData( data, function (processedData) { saveData( processedData, function () { console.log(\u0026#34;Data saved successfully\u0026#34;); }, function (error) { console.error(\u0026#34;Error saving data:\u0026#34;, error); } ); }, function (error) { console.error(\u0026#34;Error processing data:\u0026#34;, error); } ); }); 嵌套的回调难以阅读和维护。\n新时代：期约-Promise 期约是对尚不存在结果的一个替身。\n期约提供了一种更清晰和可维护的方式来处理异步操作，避免了回调地狱的问题。\n期约是基于 Promises/A+ 规范建立的。\n期约的状态 Promise 是 ECMAScript6 新增的引用类型，是一个具有状态的对象。\n它有如下三种状态：\n待定-pending。期约最初始的状态。 兑现-fullfilled。也可以称为 解决-resolved。 拒绝-rejected。 状态一经改变，不可修改。\n期约的状态是私有的，只能在内部进行操作，不能被外部代码检测和修改。\n初始化期约-new Promise(executor) 使用XMLHttpRequest模拟异步操作创建期约：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 建立请求，创建期约的工厂函数 function makeRequest(url) { return new Promise((resolve, reject) =\u0026gt; { // 异步操作 const xhr = new XMLHttpRequest(); xhr.open(\u0026#34;GET\u0026#34;, url); xhr.onload = function () { if (xhr.status \u0026gt;= 200 \u0026amp;\u0026amp; xhr.status \u0026lt; 300) { // 请求成功，将响应文本作为成功结果 resolve(xhr.responseText); } else { // 请求失败，将错误信息作为失败原因 reject(\u0026#34;请求失败，状态码: \u0026#34; + xhr.status); } }; xhr.onerror = function () { // 请求错误，将错误信息作为失败原因 reject(\u0026#34;网络错误\u0026#34;); }; xhr.send(); }); } const myPromise = makeRequest(\u0026#34;https://example.com/api/data\u0026#34;); 使用 new 创建 Promise 实例时，需要传入一个执行器（executor）函数作为参数，该函数接受两个参数：resolve 和 reject。\n前面提到期约的状态只能在内部操作，这个操作就是在执行器函数中完成的。\nresolve 会将 Promise 状态切换为 fullfilled，reject则会将其切换为 rejected。同时，调用 reject 会抛出错误。\n执行器函数是期约的初始化程序，且是同步执行的，当初始化期约时就已经改变了期约的状态。\n期约的构造器方法|静态方法之二 Promise.resolve() Promise.resolve是一个静态方法，它返回一个已解决（fulfilled）的Promise对象，并可以选择将一个值解析为成功的结果。\n如果传递给Promise.resolve的值本身已经是一个Promise对象，则它会保持不变（不会再次解析）。\n1 2 3 4 5 6 setTimeout(console.log, 0, Promise.resolve()); setTimeout(console.log, 0, Promise.resolve(1)); const p = new Promise(() =\u0026gt; {}); setTimeout(console.log, 0, Promise.resolve(p)); setTimeout(console.log, 0, p === Promise.resolve(p)); Promise.reject() Promise.reject是一个静态方法，用于创建一个已拒绝（rejected）的Promise对象，并指定一个原因（通常是一个错误对象）作为拒绝的原因。\n与Promise.resolve不同，Promise.reject不会解析传递给它的值，而是将其作为拒绝原因直接传递给Promise对象。\n1 2 3 4 5 6 setTimeout(console.log, 0, Promise.reject()); setTimeout(console.log, 0, Promise.reject(1)); const p = new Promise(() =\u0026gt; {}); setTimeout(console.log, 0, Promise.reject(p)); setTimeout(console.log, 0, p === Promise.reject(p)); 注意到，错误被抛出但没有被捕获(Uncaught)。我们给它套上try...catch试试。\n1 2 3 4 5 try { setTimeout(console.log, 0, Promise.reject()); } catch (e) { console.log(e); } 这就奇怪了，为什么还是没有捕获到错误呢？\n因为try..catch只能捕获同步代码中的错误，它位于当前执行栈中，而Promise.reject会被推入微任务队列，当当前执行栈执行完后，再执行它。\n要和异步代码交互，只能使用期约的实例方法：\nPromise.prototype.then Promise.prototype.catch Promise.prototype.finally 期约的实例方法 期约的实例方法是连接外部同步代码和内部异步代码的桥梁。\n任何暴露的异步结构，或者叫做期约的实例方法中都实现了一个then()方法。这个方法被认为实现了一个Thenable接口。\nPromise.prototype.then Promise.prototype.then是Promise对象的一个实例方法，用于附加回调函数来处理Promise的解决（fulfilled）和拒绝（rejected）状态。\n1 promise.then(onFulfilled, onRejected) then方法返回一个新的 Promise 对象，该对象有以下几种情况：\n如果onFulfilled或onRejected返回一个值（不是Promise），则返回的新Promise将以该值解决。 如果onFulfilled或onRejected抛出异常，则返回的新Promise将以该异常作为原因拒绝。注意返回错误对象会把该错误对象包装在一个解决的期约中。 如果onFulfilled或onRejected返回一个Promise，则返回的新Promise将与该返回的Promise具有相同的状态和结果。 下面是一个示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const promise = new Promise((resolve, reject) =\u0026gt; { // 模拟异步操作 setTimeout(() =\u0026gt; { const randomNumber = Math.random(); if (randomNumber \u0026lt; 0.5) { resolve(`成功：${randomNumber}`); } else { reject(`失败：${randomNumber}`); } }, 1000); }); promise.then( (result) =\u0026gt; { console.log(`成功回调：${result}`); }, (error) =\u0026gt; { console.error(`失败回调：${error}`); } ); then方法返回一个新的Promise对象，那么就可以链式调用它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 模拟延迟 function delay(ms) { return new Promise((resolve) =\u0026gt; { setTimeout(resolve, ms); }); } function fetchUserData() { return delay(1000).then(() =\u0026gt; { return { username: \u0026#34;john_doe\u0026#34;, email: \u0026#34;john@example.com\u0026#34; }; }); } function fetchUserPosts(username) { return delay(1000).then(() =\u0026gt; { return [\u0026#34;Post 1\u0026#34;, \u0026#34;Post 2\u0026#34;, \u0026#34;Post 3\u0026#34;]; }); } function displayUser(username, posts) { console.log(`Username: ${username}`); console.log(\u0026#34;Posts:\u0026#34;); posts.forEach((post, index) =\u0026gt; { console.log(`${index + 1}. ${post}`); }); } fetchUserData() .then((user) =\u0026gt; { console.log(\u0026#34;Fetching user data...\u0026#34;); console.log(user); return fetchUserPosts(user.username); }) .then((posts) =\u0026gt; { console.log(\u0026#34;Fetching user posts...\u0026#34;); console.log(posts); displayUser(\u0026#34;john_doe\u0026#34;, posts); }) .catch((error) =\u0026gt; { console.error(\u0026#34;Error:\u0026#34;, error); }); 输出：\n1 2 3 4 5 6 7 8 9 Fetching user data... { username: \u0026#39;john_doe\u0026#39;, email: \u0026#39;john@example.com\u0026#39; } Fetching user posts... [ \u0026#39;Post 1\u0026#39;, \u0026#39;Post 2\u0026#39;, \u0026#39;Post 3\u0026#39; ] Username: john_doe Posts: 1. Post 1 2. Post 2 3. Post 3 then的链式调用避免了回调地狱，提高了代码的可维护性。\nPromise.prototype.catch 虽然then方法已经可以为期约添加拒绝处理程序：promise.then(null,onRejected)，但是这样不是很美观，于是就有了语法糖：promise.catch(onRejected)。\n行为上与then是一致的。这里不再细究。\nPromise.prototype.finally finally方法用于给程序添加onFinally回调函数，该回调无论Promise对象是fulfilled还是rejected都会执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const promise = new Promise((resolve, reject) =\u0026gt; { // 模拟异步操作 setTimeout(() =\u0026gt; { const randomNumber = Math.random(); if (randomNumber \u0026lt; 0.5) { resolve(`成功：${randomNumber}`); } else { reject(`失败：${randomNumber}`); } }, 1000); }); promise .then( (result) =\u0026gt; { console.log(`成功回调：${result}`); }, (error) =\u0026gt; { console.error(`失败回调：${error}`); } ) .finally(() =\u0026gt; { console.log(\u0026#34;不管成功或失败，都会执行这里的回调\u0026#34;); }); 大多数情况下，调用finally会原样返回期约。\n如果期约是待定的且在onFinally处理程序中抛出错误或返回了一个拒绝期约，则会返回一个拒绝期约。\n这个方法避免了then和catch的onFufilled和onRejected中出现重复冗余代码。\n期约的非重入non-reentrancy特性 当一个期约进入\u0026quot;落定状态\u0026quot;（settled state）时，与该状态相关的处理程序（例如，.then或.catch中的回调函数）不会立即执行，而是会被排入执行队列，等待事件循环处理。\n一旦Promise对象进入了已成功或已失败状态，它就被认为是\u0026quot;落定\u0026quot;，不再处于悬挂状态。在这个状态下，Promise的结果或错误已经确定，不会再发生变化。\n与附加处理程序相关的同步代码（即添加处理程序的代码之后的代码）会在处理程序执行之前优先执行。\n这个特性的存在是为了确保期约处理程序的执行不会中断当前执行的同步代码块。\n1 2 Promise.resolve().then(() =\u0026gt; console.log(\u0026#34;onResolved 执行\u0026#34;)); console.log(\u0026#34;同步代码执行\u0026#34;); 输出\n1 2 同步代码执行 onResolved 执行 更为精彩的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 创建一个Promise const myPromise = new Promise((resolve, reject) =\u0026gt; { console.log(\u0026#34;Promise开始执行\u0026#34;); // 模拟异步操作 setTimeout(() =\u0026gt; { resolve(\u0026#34;成功\u0026#34;); // 期约进入落定状态 }, 2000); console.log(\u0026#34;resolve() 返回\u0026#34;); }); console.log(\u0026#34;Promise创建完成\u0026#34;); // 添加处理程序 myPromise.then((result) =\u0026gt; { console.log(`处理程序执行，结果为：${result}`); }); console.log(\u0026#34;处理程序添加完成\u0026#34;); // 同步代码 console.log(\u0026#34;同步代码执行\u0026#34;); 输出\n1 2 3 4 5 6 Promise开始执行 resolve() 返回 Promise创建完成 处理程序添加完成 同步代码执行 处理程序执行，结果为：成功 哪怕你把期约状态变化的代码的封装放在添加处理程序之后，结果也是一样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 let synchronousResolve; // 创建一个Promise const myPromise = new Promise((resolve, reject) =\u0026gt; { synchronousResolve = function () { console.log(\u0026#34;Promise开始执行\u0026#34;); // 模拟异步操作 setTimeout(() =\u0026gt; { resolve(\u0026#34;成功\u0026#34;); // 期约进入落定状态 }, 2000); console.log(\u0026#34;resolve() 返回\u0026#34;); } }); console.log(\u0026#34;Promise创建完成\u0026#34;); // 添加处理程序 myPromise.then((result) =\u0026gt; { console.log(`处理程序执行，结果为：${result}`); }); synchronousResolve(); console.log(\u0026#34;处理程序添加完成\u0026#34;); // 同步代码 console.log(\u0026#34;同步代码执行\u0026#34;); 邻近处理程序的执行顺序 当给一个期约（Promise）添加多个处理程序（例如，.then()、.catch()、.finally()），这些处理程序会按照它们被添加的顺序依次执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const myPromise = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;成功\u0026#34;); }, 2000); }); myPromise .then((result) =\u0026gt; { console.log(`第一个处理程序执行，结果为：${result}`); }) .then(() =\u0026gt; { console.log(\u0026#34;第二个处理程序执行\u0026#34;); }) .catch((error) =\u0026gt; { console.error(`捕获到错误：${error}`); }) .finally(() =\u0026gt; { console.log(\u0026#34;无论如何都会执行的finally处理程序\u0026#34;); }); 输出\n1 2 3 第一个处理程序执行，结果为：成功 第二个处理程序执行 无论如何都会执行的finally处理程序 传递解决值和拒绝理由 当一个Promise对象进入\u0026quot;已成功\u0026quot;或\u0026quot;已失败\u0026quot;的落定状态后，它会提供相应的解决值（如果成功）或拒绝理由（如果失败）给与之相关联的处理程序。这些解决值和拒绝理由会作为函数参数传递给处理程序，从而允许进一步操作这些值。\n当一个Promise成功（通过调用resolve()）时，解决值会传递给.then()处理程序，允许您进一步操作这个值。 当一个Promise失败（通过调用reject()）时，拒绝理由会传递给.catch()处理程序，允许您处理错误情况。 在执行Promise的执行器函数中，解决值和拒绝理由是作为resolve()和reject()函数的第一个参数传递的。 Promise.resolve()和Promise.reject()方法在被调用时也可以接收解决值和拒绝理由，并返回一个已经处于相应状态的Promise对象。这些值将会传递给与之关联的处理程序。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 function fetchDataFromServer(url) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { const success = Math.random() \u0026lt; 0.7; if (success) { const data = { id: 1, name: \u0026#34;John Doe\u0026#34; }; resolve(data); // 请求成功，传递数据 } else { reject(\u0026#34;网络请求失败\u0026#34;); // 请求失败，传递错误信息 } }, 1000); }); } fetchDataFromServer(\u0026#34;https://example.com/api/data\u0026#34;) .then((response) =\u0026gt; { console.log(\u0026#34;成功获取数据：\u0026#34;, response); // 在这里可以对获取到的数据进行操作 return response.name; // 返回一个新值 }) .catch((error) =\u0026gt; { console.error(\u0026#34;网络请求错误：\u0026#34;, error); // 在这里可以处理网络请求失败的情况 throw new Error(\u0026#34;处理失败\u0026#34;); //不会阻止代码执行 }) .then((value) =\u0026gt; { console.log(\u0026#34;在第二个.then()中获取的值：\u0026#34;, value); }) .catch((error) =\u0026gt; { console.error(\u0026#34;在第二个.catch()中获取的错误：\u0026#34;, error.message); }); console.log(\u0026#34;网络请求已发出\u0026#34;); 图1\n图2\n期约连锁形成Promise链 前文提到过then的链式调用，也被称为期约连锁，then、catch和finally都返回一个新期约对象，链式调用它们就会形成一条期约链。\n1 2 3 4 5 6 7 8 9 10 function delay(ms, str) { return new Promise((resolve) =\u0026gt; { console.log(str); setTimeout(resolve, ms); }); } delay(1000, \u0026#34;promise 1\u0026#34;) .then(() =\u0026gt; delay(1000, \u0026#34;promise 2\u0026#34;)) .then(() =\u0026gt; delay(1000, \u0026#34;promise 3\u0026#34;)) .then(() =\u0026gt; delay(1000, \u0026#34;promise 4\u0026#34;)); 期约图的概念 一个期约可能对应多个处理程序。每个处理程序也可能返回一个新期约。\n这就可能形成期约图。\n期约图中，一个期约是一个节点，期约的处理程序则是对应期约的不同边。\n1 2 3 4 5 6 7 8 9 10 let A = new Promise((resolve, reject) =\u0026gt; { console.log(\u0026#34;A\u0026#34;); resolve(); }); let B = A.then(() =\u0026gt; console.log(\u0026#39;B\u0026#39;)); let C = A.then(() =\u0026gt; console.log(\u0026#39;C\u0026#39;)); B.then(() =\u0026gt; console.log(\u0026#39;D\u0026#39;)); B.then(() =\u0026gt; console.log(\u0026#39;E\u0026#39;)); C.then(() =\u0026gt; console.log(\u0026#39;F\u0026#39;)); C.then(() =\u0026gt; console.log(\u0026#39;G\u0026#39;)); 如上代码形成如下有向非循环的期约图：\n期约合成的静态方法 期约合成是指将多个期约组合成一个期约。\nPromise.all Promise.all 方法创建的期约会在一组期约全部解决后再解决，即并行执行多个异步操作，并在所有操作都成功完成时才返回结果，如果其中任何一个失败，Promise.all 方法立即返回失败的期约。\n1 Promise.all(iterable); Promise.all 接受一个可迭代对象作为参数。可迭代对象的元素会通过 Promise.resolve 转换为期约。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function createPromise() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { const randomnNumber = Math.random(); (randomnNumber \u0026lt; 0.5 \u0026amp;\u0026amp; resolve(`成功: ${randomnNumber}`)) || reject(`失败: ${randomnNumber}`); }, 1000); }); } let p = Promise.all([createPromise(), createPromise()]); console.log(p); p.then(() =\u0026gt; { console.log(\u0026#34;all resolved\u0026#34;); }).catch(() =\u0026gt; { console.log(\u0026#34;one rejected\u0026#34;); }); Promise.race 和Promise.all一样，Promise.race接受一个可迭代对象作为参数。可迭代对象的元素会通过Promise.resolve转换为期约。\n不同的是，race表示“竞争；角逐”的意思，Promise.race的可迭代对象的元素转换后的期约谁先settled就返回谁。\n参考资料 JavaScript高级程序设计（第4版） ","date":"2023-10-10T00:00:00Z","permalink":"http://localhost:1313/p/javascriptpromise/","title":"【JavaScript】Promise"},{"content":"简介 this是函数内部的特殊对象之一（其他还有arguments、caller、new.target）。\nthis的指向或值是不确定的，取决于函数的调用方式。并且在严格模式和非严格模式下的表现也不同。\n全局上下文中的this 当函数不作为对象的属性被调用时，this指向全局对象，浏览器中是window对象。\n1 2 3 console.log(this); this.name = \u0026#39;Hello\u0026#39;; console.log(window.name); // Hello 无论使不使用严格模式，上面的this都指向全局对象。\n不论在哪个上下文环境，都可以使用globalThis获取全局对象。\n函数上下文中的this 函数内部的this由函数的调用方式决定。\n1 2 3 4 5 6 7 8 9 10 const obj = { getThis: function () { console.log(this); }, }; function getThis() { console.log(this); } obj.getThis(); getThis(); 若是使用严格模式，this的值需要自行指定为任意值，默认为undefined。\n1 2 3 4 function getThis() { \u0026#34;use strict\u0026#34;; console.log(this); } 函数作为对象方法被调用时，this绑定为调用的对象。\n形式为obj.func()，func的this被绑定为obj,无论func是否是obj原型链上的方法。\n类上下文中的this 类的本质是也是函数。\n类的所有非静态方法都被添加到类的构造函数中的this的原型上。\n1 2 3 4 5 6 7 8 9 10 11 class Example { constructor() { const proto = Object.getPrototypeOf(this); console.log(Object.getOwnPropertyNames(proto)); } first(){} second(){} static third(){} } new Example(); // [\u0026#39;constructor\u0026#39;, \u0026#39;first\u0026#39;, \u0026#39;second\u0026#39;] 派生类中的this 派生类中的构造函数中的this不会自动绑定，需要使用super()，相当于this = new Base()，其中Base为基类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Base {} // 派生类没有构造函数 class Good extends Base {} // 派生类构造函数返回一个对象替换this class AlsoGood extends Base { constructor() { return { a: 5 }; } } class Better extends Good { constructor() { super(); } } // 派生类带有空构造函数 class Bad extends Base { constructor() {} } new Good(); new AlsoGood(); new Better(); new Bad(); // Uncaught ReferenceError: must call super constructor before using \u0026#39;this\u0026#39; in derived class constructor call、apply和bind绑定this 当使用call或apply调用时，this指向传入的第一个参数。\n1 2 3 func.call(thisArg, arg1, arg2, ...); func.apply(thisArg, [argsArray]); // argsArray为参数数组 func.bind(thisArg, arg1, arg2, ...); call和bind的区别：call会立即执行函数，bind不会立即执行函数，而是返回一个新函数，你可以随时调用它。但是bind只生效一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function add(c, d) { return this.a + this.b + c + d; } var o = { a: 1, b: 3 }; // 第一个参数是用作“this”的对象 // 其余参数用作函数的参数 add.call(o, 5, 7); // 16 // 第一个参数是用作“this”的对象 // 第二个参数是一个数组，数组中的两个成员用作函数参数 add.apply(o, [10, 20]); // 34 // 第一个参数是用作“this”的对象 // 其余参数用作函数的参数 let newAdd = add.bind(o, 11, 22); newAdd(); // 37 newAdd = newAdd.bind({ a: 0, b: 0 }, 11, 22); // 37 call、apply和bind如果传入的this参数不是对象，而是原始值：\n数字，this = new Number(num) 字符串，this = new String(str) null或undefined，this = globalThis 箭头函数中的this 箭头函数中的this与封闭词法环境的this保持一致。\n通俗点说，就是与定义时而非调用时在的词法环境的this保持一致。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var globalObject = this; var foo = () =\u0026gt; this; console.log(foo() === globalObject); // true // 作为对象的一个方法调用 var obj = { foo: foo }; console.log(obj.foo() === globalObject); // true // 尝试使用 call 来设定 this console.log(foo.call(obj) === globalObject); // true // 尝试使用 bind 来设定 this foo = foo.bind(obj); console.log(foo() === globalObject); // true call、apply和bind都无法改变箭头函数的this。\n位于函数中的箭头函数：\n1 2 3 function foo(){ return () =\u0026gt; this; } foo返回了一个匿名函数，称为A，那么A返回的this与foo函数的this保持一致，而foo的this与其调用时所在词法环境的this一致。\n1 2 3 4 5 6 7 8 9 10 function foo() { return () =\u0026gt; this; } foo()(); // Window function bar() { return foo(); } bar()(); // Window const obj = { a:1} foo.call(obj)().a; // 1 参考资料 this globalThis ","date":"2023-10-10T00:00:00Z","permalink":"http://localhost:1313/p/javascriptthis/","title":"【JavaScript】this"},{"content":"从单词释义上看，type of——某某的类型，instance of——某某的实例。\n从作用上看，typeof返回右值的数据类型的字符串表示。如下代码展示常见类型及typeof的对应输出：\n1 2 3 4 5 6 7 8 console.log(typeof 520) //\u0026#34;number\u0026#34; console.log(typeof \u0026#34;1314\u0026#34;) //\u0026#34;string\u0026#34; console.log(typeof true) //\u0026#34;boolean\u0026#34; console.log(typeof undefined) //\u0026#34;undefined\u0026#34; console.log(typeof {}) //\u0026#34;object\u0026#34; console.log(typeof function(){}) //\u0026#34;function\u0026#34; console.log(typeof Symbol(\u0026#34;ShadowKylin\u0026#34;)) //\u0026#34;symbol\u0026#34; console.log(typeof null); //\u0026#34;object\u0026#34; typeof对于原始值很有用，但不能有效区分数组、对象。\ninstanceof用于检查对象是否属于某个类的实例，换言之，是否是某个构造函数的实例，再换言之，是否在原型链上继承自该构造函数的原型。如下面代码所示：\n1 2 3 4 5 class Person {} const person=new Person() console.log(person instanceof Person)\t//true console.log(person instanceof Object)\t//true，Object是所有对象的基类 那就要想了，能不能用typeof判断实例，或者用instanceof判断类型呢？当然都不能了。实例是对象，对象类型就是object；instanceof要求左值为对象，所以只能判断对象，1 instanceof Number结果是false。\n","date":"2023-10-10T00:00:00Z","permalink":"http://localhost:1313/p/javascripttypeof%E5%92%8Cinstanceof/","title":"【JavaScript】typeof和instanceof"},{"content":"引言 浅拷贝、深拷贝是对引用类型而言的。\n引用类型的变量对应一个栈区地址，这个栈区地址处存储的值是存放的真正的数据的堆区地址。\n基本数据类型的变量也对应一个栈区地址，但是该地址存储的是其真正的值。\nlet a = b发生了什么？\nlet obj2 = obj1发生了什么？\nJavaScript的数据类型：\n什么是浅拷贝？ 浅拷贝（shallow copy）创建的新对象拷贝的是原对象的属性的栈区地址。\n图中同名变量的栈区地址相同，不同名变量的栈区地址不同。\na和_a、b和_b都是复制了原来栈区地址的值，对_a的修改不会影响a，对_b的修改却会影响b，因为它们相当于let _b = b的关系。\n什么是深拷贝？ 深拷贝（deep copy）拷贝对象的堆区数据为新副本，如此新旧对象不会互相影响。\n浅拷贝的方法有哪些？ 1.JavaScript中对象的合并，Object.assign本身是浅拷贝。\n1 2 3 4 5 6 7 const originalObject = {a:1,b:{c:1}} const shallowCopy = Object.assign({}, originalObject); console.log(shallowCopy === originalObject);//false，比较的是栈区地址 shallowCopy.a = 2; shallowCopy.b.c = 2; console.log(originalObject.a);// 1 console.log(originalObject.b.c);// 2 缺陷：Object.assign不会拷贝继承属性、不可枚举属性。\n2.展开语法\n1 let newObj = {...obj} 3.数组的cancat方法\n1 const newArr = oldArr.concat([]) 4.数组的slice方法\n1 const newArr = oldArr.slice(start[,end]); 5.浅拷贝细致点看，是先创建一个新对象，然后将原对象的属性直接复制到新对象，所以也可以自己写一个浅拷贝函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 function shallowCopy(obj) { if (obj === null || typeof obj !== \u0026#34;object\u0026#34;) return obj; const newObj = new obj.constructor(); for (let key of Reflect.ownKeys(obj)) { newObj[key] = obj[key]; } return newObj; } // Object.prototype.d = 1; const obj1 = { a: 1, b: { c: 1 } }; const obj2 = shallowCopy(obj1); obj2.a = 2; obj2.b.c = 2; 6.lodash库的浅拷贝方法\n如何实现深拷贝？ 1.JSON.stringify()与JSON.parse()\n1 2 3 4 function deepClone(obj){ if(obj === null || typeof obj !== \u0026#39;object\u0026#39;) return obj; return JSON.parse(JSON.stringify(obj)); } 缺陷：\n丢失function、undefined、Symbol这几种类型的键值对 NaN、Infinity的值会转为null Date会变为字符串 RegExp会变成空对象 不能拷贝不可枚举属性及原型链上的属性 不能解决循环引用 2.lodash库的深拷贝方法\n3.手动实现深拷贝函数基础版：\n1 2 3 4 5 6 7 8 function deepClone(obj) { if(obj === null || typeof obj !== \u0026#39;object\u0026#39;) return obj; const newObj = new obj.constructor(); for (let key of Reflect.ownKeys(obj)) { newObj[key] = typeof obj[key] === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; obj[key] !== null ? arguments.callee(obj[key]) : obj[key]; } return newObj; } const newObj = new obj.constructor()相比于使用{}，保持了原型链的继承。\n缺陷：\n不能处理循环引用，可能会导致堆栈溢出 对Array、Date、RegExp、Map、Set对象的处理不好 4.手动实现深拷贝函数进阶版：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const deepClone = function (obj, hash = new WeakMap()) { if(obj === null || typeof obj !== \u0026#39;object\u0026#39;) return obj; // 防止循环引用 if (hash.has(obj)) return hash.get(obj); // 如果参数为Date, RegExp, Set, Map, WeakMap, WeakSet等引用类型，则直接生成一个新的实例 let type = [Date, RegExp, Set, Map, WeakMap, WeakSet]; if (type.includes(obj.constructor)) return new obj.constructor(obj); const newObj = new obj.constructor(); for (let key of Reflect.ownKeys(obj)) { newObj[key] = typeof obj[key] === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; obj[key] !== null ? arguments.callee(obj[key]) : obj[key]; } // 哈希表设值 hash.set(obj, cloneObj); return cloneObj; }; 参考资料 JavaScript中浅拷贝和深拷贝的区别与实现 JavaScript深拷贝和浅拷贝看这篇就够了 关于堆栈的讲解(我见过的最经典的) 深入理解js数据类型与堆栈内存 js中深浅拷贝的实现方式(含图解原理) JavaScript深拷贝看这篇就行了！（实现完美的ES6+版本） 【JavaScript】arguments.callee的作用及替换方案 [javascript核心-15]手写完美深拷贝代码实现🍌 JS中JSON序列化JSON.stringify的坑点和处理 Reflect.ownKeys() ","date":"2023-10-10T00:00:00Z","permalink":"http://localhost:1313/p/javascript%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1/","title":"【JavaScript】理解对象"},{"content":"引言 组件间的关系有父子关系、兄弟关系、祖孙关系和远亲关系。\n不同的关系间，组件的通信有不同的方式。\n一、prop 和 $emit prop向下传递，emit向上传递。\n父组件使用prop向子组件传递信息。\nParentComponent.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ChildComponent msg=\u0026#34;Hello,this is the message passed from the parent component.\u0026#34;\u0026gt; \u0026lt;/ChildComponent\u0026gt; \u0026lt;ChildComponent :msg=\u0026#34;parentMsg\u0026#34;\u0026gt; \u0026lt;/ChildComponent\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; export default { data() { return { parentMsg: \u0026#39;Hello,this is the message passed from the parent component.\u0026#39; } }, components: { ChildComponent } } \u0026lt;/script\u0026gt; ChildComponent.vue\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{{ msg }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: { msg: String } } \u0026lt;/script\u0026gt; 子组件通过实例的事件方法 $emit 向父组件通信\n$emit 触发一个自定义事件，并接受一个参数作为抛出值。父组件通过 $event 或回调函数获取传递值。\nParentComponent.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{{ msg }}\u0026lt;/p\u0026gt; \u0026lt;!-- \u0026lt;ChildComponent @custom-event=\u0026#34;handleCustomEvent\u0026#34;\u0026gt;\u0026lt;/ChildComponent\u0026gt; --\u0026gt; \u0026lt;!-- 或者 --\u0026gt; \u0026lt;ChildComponent @custom-event=\u0026#34;msg=$event\u0026#34;\u0026gt;\u0026lt;/ChildComponent\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; export default { data() { return { msg: \u0026#39;现在为空\u0026#39; } }, components: { ChildComponent }, methods: { handleCustomEvent(msg) { this.msg = msg; } }, } \u0026lt;/script\u0026gt; ChildComponent.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;sendMsgToParent\u0026#34;\u0026gt;发送消息到父组件\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { msg: \u0026#39;Hello,this is the message passed from child component.\u0026#39; } }, methods: { sendMsgToParent() { this.$emit(\u0026#39;custom-event\u0026#39;, this.msg); } } } \u0026lt;/script\u0026gt; 优先使用 prop 和 事件进行父子组件间的通信。\n二、$parent 和 $children 子实例可以用 this.$parent 访问父实例，同时子实例被推入父实例的 $children 数组中。\nParentComponent.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;父组件\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;来自子组件 1 的消息:{{ msg1 }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;来自子组件 2 的消息:{{ msg2 }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;receiveMsgFromChildren\u0026#34;\u0026gt;接收子组件的消息\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;button @click=\u0026#34;msg1= \u0026#39;现在为空\u0026#39;;msg2=\u0026#39;现在为空\u0026#39;\u0026#34;\u0026gt;清空\u0026lt;/button\u0026gt; \u0026lt;ChildComponent1 /\u0026gt; \u0026lt;ChildComponent2 /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent1 from \u0026#39;./ChildComponent1.vue\u0026#39;; import ChildComponent2 from \u0026#39;./ChildComponent2.vue\u0026#39; export default { data() { return { msg1: \u0026#39;现在为空\u0026#39;, msg2: \u0026#39;现在为空\u0026#39; } }, components: { ChildComponent1, ChildComponent2 }, methods: { receiveMsgFromChildren() { this.msg1 = this.$children[0].msg; this.msg2 = this.$children[1].msg; } }, } \u0026lt;/script\u0026gt; ChildComponent1.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;子组件1\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;sendMsgToParent\u0026#34;\u0026gt;发送消息给父组件\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { msg: \u0026#39;Hello,this is the message passed from child component1.\u0026#39; } }, methods: { sendMsgToParent() { this.$parent.msg1 = this.msg; } } } \u0026lt;/script\u0026gt; ChildComponent2.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;子组件2\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;sendMsgToParent\u0026#34;\u0026gt;发送消息给父组件\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { msg: \u0026#39;Hello,this is the message passed from child component2.\u0026#39; } }, methods: { sendMsgToParent() { this.$parent.msg2 = this.msg; } } } \u0026lt;/script\u0026gt; 三、依赖注入 依赖注入设置两个选项：provide 和 inject\nprovide 选项允许我们提供一系列数据或方法。然后在设置了 provide 选项的组件的所有后代组件里都可以通过 inject 选项获取这些数据或方法。\nprovide 选项应该是一个对象或返回一个对象的函数。\n1 2 3 4 5 6 7 8 9 provide: { foo: \u0026#39;bar\u0026#39; } provide: { return { foo: \u0026#39;bar\u0026#39; } } inject 选项可以为以下值：\n一个字符串数组，其元素值为 provide 属性的 key。 一个对象，对象的 key 是绑定在本地的，可以与 provide 不同，如果要设置为不同名的属性，那么就要给该属性设置 from 属性来说明它来自哪个 provide 提供的属性，同时你可以为它提供默认值 default。 1 2 3 4 5 6 7 8 inject: [\u0026#39;foo\u0026#39;] inject: { foo: { from: \u0026#39;bar\u0026#39; default： \u0026#39;foo\u0026#39; } } 四、ref 和 $refs ref 属性为普通 DOM 元素或子组件指定引用，该引用会被注册到父组件的 $refs 对象上。\n1 2 3 \u0026lt;div ref=\u0026#34;div\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;child-component ref=\u0026#34;child\u0026#34; /\u0026gt; 使用\n1 2 3 vm.$refs.div vm.$refs.child 如果你尝试在 created 或 mounted 钩子中访问 ref，通常会得到 undefined。因为 ref 本身是作为渲染结果被创建的，在初始渲染（beforeUpdate之前）的时候你不能访问它们。\n五、事件总线 使用事件总线进行组件间通信的步骤：\n1.创建事件总线\n1 2 3 // EventBus.js import Vue from \u0026#39;vue\u0026#39;; export const EventBus = new Vue(); 2.引入事件总线\n1 import { EventBus } from \u0026#39;./EventBus.js\u0026#39;; 3.在发送组件中触发事件\n1 EventBus.$emit(\u0026#39;custom-event\u0026#39;,eventData); 4.在接收组件中监听事件\n1 2 3 EventBus.$on(\u0026#39;custom-event\u0026#39;,(data)=\u0026gt;{ //处理 data }); 5.移除监听事件\n1 EventBus.$off(\u0026#39;custom-event\u0026#39;)​ 六、$attrs 与 $listeners $attrs包含了父组件传递给子组件的所有没有在子组件 props 中声明的属性（除了class和style）。当子组件没有声明任何props时，$attrs中会包含所有父组件传递的属性（除了class和style），这在创建高级别的通用组件时非常有用，因为你无需知道父组件会传递哪些属性。\n下面是一个示例来说明$attrs的用法：\n假设我们有一个名为MyButton的子组件，它可以接收label属性，但同时也希望允许父组件传递任意额外的HTML属性给按钮元素。我们可以使用$attrs来实现这一点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;button v-bind=\u0026#34;$attrs\u0026#34;\u0026gt; {{ label }} \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: { label: String, }, }; \u0026lt;/script\u0026gt; 在这个示例中，MyButton组件只声明了一个名为label的prop，但它使用v-bind=\u0026quot;$attrs\u0026quot;将所有父组件传递的属性绑定到按钮元素上。这意味着，父组件可以像这样使用MyButton：\n1 \u0026lt;MyButton label=\u0026#34;Click me\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; id=\u0026#34;my-button\u0026#34; @click.native=\u0026#34;handleClick\u0026#34; /\u0026gt; 在这里，class和id属性会被传递到\u0026lt;button\u0026gt;元素，而label会被解析为\u0026quot;Click me\u0026quot;，同时@click事件也会正常工作。\n$listeners 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\u0026quot;$listeners\u0026quot; 传入内部组件——在创建更高层次的组件时非常有用。\nParentComponent.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;MyButton label=\u0026#34;Click me\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; id=\u0026#34;my-button\u0026#34; @click=\u0026#34;handleClick\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import MyButton from \u0026#39;./MyButton.vue\u0026#39; export default { components: { MyButton }, methods: { handleClick() { console.log(\u0026#39;点击了1次\u0026#39;) } } }; \u0026lt;/script\u0026gt; MyButton.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;button v-bind=\u0026#34;$attrs\u0026#34; v-on=\u0026#34;$listeners\u0026#34;\u0026gt; {{ label }} \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: { label: String, }, }; \u0026lt;/script\u0026gt; 七、Vuex 以后专门学习，在此不做介绍先。\n八、浏览器客户端存储 MDN-客户端存储\n参考资料 ","date":"2023-09-17T00:00:00Z","permalink":"http://localhost:1313/p/vue-2%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/","title":"【Vue 2】组件间的通信方式"},{"content":"ECMA-262将对象定义为一组属性的无序集合。\n1 内部属性描述 1.1 数据属性 [[Configurable]]：可配置性，直接定义在对象的属性该特性默认为 true，表示可以对属性进行删除、修改等操作。 [[Enumerable]]：可枚举性，直接定义在对象的属性该特性默认为 true，它决定了我们是否可以通过for-in循环遍历对象的属性。 [[Writable]]：可写性，直接定义在对象的属性该特性默认为 true，表示属性的值是否可以被修改。 [[Value]]：属性的实际数据值，默认为 undefined。 我们可以使用Object.defineProperty来定义数据属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let student1 = { name: \u0026#34;student1\u0026#34; }; Object.defineProperty(student1, \u0026#34;sex\u0026#34;, { configurable: false, enumerable: false, writable: false, value: \u0026#34;male\u0026#34;, }); //测试可配置性 delete student1.sex; console.log(student1.sex); console.log(); //测试可枚举性 for (const key in student1) { console.log(key + \u0026#34; \u0026#34;); } console.log(); //测试可写性 student1.sex = \u0026#34;female\u0026#34;; console.log(student1.sex); 输出：\n1 2 3 4 5 male name male 除了属性configurable属性为false的情况，我们可以多次调用defineProperty。\n如果调用了 defineProperty 但不指定 configurable、enumerable、writable的值，则它们默认被设为 false。\n1.2 访问器属性 [[Configurable]]：表示属性是否可修改。直接定义在对象的属性该特性默认为true。 [[Enumberable]]：表示属性是否可枚举。直接定义在对象的属性该特性默认为true。 [[Get]]：获取属性时调用的函数。默认为undefined。 [[Set]]：设置属性时调用的函数。默认为undefined。 同样我们使用Object.defineProperty来定义访问器属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let person = { firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34;, }; Object.defineProperty(person, \u0026#39;fullName\u0026#39;, { get() { return this.firstName + \u0026#34; \u0026#34; + this.lastName; }, set(value) { const parts = value.split(\u0026#34; \u0026#34;); this.firstName = parts[0]; this.lastName = parts[1]; } }); console.log(person.fullName); person.fullName = \u0026#34;Jane Smith\u0026#34;; console.log(person.firstName); console.log(person.lastName); 输出：\n1 2 3 John Doe Jane Smith 访问器属性和数据属性的不同之处在于：数据属性关注于数据的值与可写性，访问器属性关注获取和设置数据时进行的操作。\n2 定义多个属性 可以使用Object.defineProperties一次性定义多个属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 let person={}; Object.defineProperties(person,{ name:{ value: \u0026#39;Jane\u0026#39; }, age:{ get(){ return this.age; }, set(value){ this.age=value; } } }); 3 读取属性特性 使用Object.getOwnPropertyDescriptor读取属性的属性描述符。\n使用上面一节中定义好的person对象。\n1 2 3 4 5 6 7 8 9 10 let descriptor1=Object.getOwnPropertyDescriptor(person,\u0026#39;name\u0026#39;); console.log(\u0026#39;descriptor1.configurable：\u0026#39;+descriptor1.configurable); console.log(\u0026#39;descriptor1.enumerable：\u0026#39;+descriptor1.enumerable); console.log(\u0026#39;descriptor1.writable：\u0026#39;+descriptor1.writable); console.log(\u0026#39;descriptor1.value：\u0026#39;+descriptor1.value); let descriptor2=Object.getOwnPropertyDescriptor(person,\u0026#39;age\u0026#39;); console.log(\u0026#39;descriptor2.configurable：\u0026#39;+descriptor2.configurable); console.log(\u0026#39;descriptor2.enumerable：\u0026#39;+descriptor2.enumerable); console.log(\u0026#39;descriptor2.get：\u0026#39;+descriptor2.get); console.log(\u0026#39;descriptor2.set：\u0026#39;+descriptor2.set); 运行结果：\n1 2 3 4 5 6 7 8 9 10 11 12 descriptor1.configurable：false descriptor1.enumerable：false descriptor1.writable：false descriptor1.value：Jane descriptor2.configurable：false descriptor2.enumerable：false descriptor2.get：get() { return this.age; } descriptor2.set：set(value) { this.age = value; } 注意到没有设置的configurable、enumerable、writable都被设置为false。\n4 合并对象 合并对象即将一个对象的属性复制到目标对象上，这也被称为混入（mixin）。学过Vue的知道，Vue里面也有个混入的概念，Vue2 混入。\nES6提供Object.assign()方法来合并对象。\n该方法将一个或多个源对象的可枚举和自有属性复制到目标对象上。\n可枚举判断：Object.propertyIsEnumerable()。 自有属性判断：Object.hasOwnProperty()。 复制的具体操作是调用源对象的get获取属性，再调用目标对象的set属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const target = { _a:\u0026#39;\u0026#39;, // set a(val) { // console.log(\u0026#34;调用target属性a的set\u0026#34;); // this._a = val; // } }; Object.defineProperty(target, \u0026#39;a\u0026#39;, { set(val) { console.log(\u0026#39;调用target属性a的set\u0026#39;); this._a = val; }, }); const source1 = { // get a() { // console.log(\u0026#34;调用source1属性a的get\u0026#34;); // return \u0026#34;a\u0026#34;; // } }; Object.defineProperty(source1, \u0026#34;a\u0026#34;, { get() { console.log(\u0026#34;调用source1属性a的get\u0026#34;); return \u0026#34;a\u0026#34;; }, enumerable: true }); const source2 = { b: \u0026#39;b\u0026#39; }; Object.assign(target, source1, source2); console.log(target); 在对象字面量中定义的属性的未设置的数据属性和访问器属性都为默认值，而在Object.defineProperty中定义的属性的未设置的特性要么为false，要么为undefined。\n上面我们给source1的访问器属性a设置enumerable: true就是这个原因，不然无法复制a属性。\n运行结果：\n1 2 3 调用source1属性a的get 调用target属性a的set { _a: \u0026#39;a\u0026#39;, b: \u0026#39;b\u0026#39; } Object.assign还有以下注意的地方：\n遇到同名的属性，后面的会覆盖前面的。\nObject.assign是浅复制，即只复制对象内部元素的引用。\n1 2 3 4 const originalObject={a:1} const anotherShallowCopy = Object.assign({}, originalObject); console.log(anotherShallowCopy === originalObject);//false console.log(anotherShallowCopy.a === originalObject.a);//true 在复制过程出现错误，Object.assign不会回滚到初始状态。\n5 严格相等判断 大多数情况我们可以使用===来判断严格相等，但以下的特殊边界情况却不尽人意：\n1 2 3 4 console.log(+0 === -0); //true console.log(+0 === 0); //true console.log(-0 === 0); //true console.log(NaN === NaN); //false 其中NaN表示Not a Number，可以使用全局函数isNaN检查。\nES6提供了Object.is来应对上述所有情况。\n1 Object.is(v1,v2); 使用递归+Object.is+剩余参数比较多个值的相等性：\n1 2 3 function areValuesEqual(a,...values){ return Object.is(a,values[0])\u0026amp;\u0026amp;(values.length\u0026lt;2||areValuesEqual(...values)); } 或者使用every：\n1 2 3 function areValuesEqual(a, ...values) { return values.every(value =\u0026gt; Object.is(a, value)); } 6 增强的对象语法 6.1 属性值的简写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const name = \u0026#34;John\u0026#34;; const age = 30; // 使用属性值简写创建对象 const person = { name, age, sayHello() { console.log(`Hello, my name is ${this.name}.`); } }; console.log(person); // 输出 { name: \u0026#39;John\u0026#39;, age: 30 } person.sayHello(); // 输出 \u0026#34;Hello, my name is John.\u0026#34; 6.2 可计算属性 可计算属性允许你在定义对象时在方括号内使用表达式来定义对象名。\n1 2 3 4 5 6 7 8 9 const methodSuffix = \u0026#34;Hello\u0026#34;; const dynamicObject = { [\u0026#34;say\u0026#34; + methodSuffix]() { console.log(\u0026#34;Hello, World!\u0026#34;); } }; dynamicObject.sayHello(); // 输出 \u0026#34;Hello, World!\u0026#34; 6.3 简写属性名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let key=\u0026#39;Age\u0026#39;; let person={ _name: \u0026#39;Jane\u0026#39;, _age: \u0026#39;18\u0026#39;, get name(){ return this._name; }, set name(val){ this._name=val; }, sayHello() { console.log(`Hello, my name is ${this._name}.`); }, [\u0026#39;say\u0026#39;+key](){ console.log(`Hello, my age is ${this._age}.`); } }; 7 对象解构 对象解构指可以使用与对象匹配的结构来实现对象属性赋值。\n1 2 3 4 5 6 7 8 9 10 11 12 let person={ name: \u0026#39;Jane\u0026#39;, age: 18 }; //别名 let {name:personName,age:personAge}=person; //属性简写 let {name,age}=person; //没有匹配的属性被赋值为undefined let {name,age,height}=person; //解构时赋值 let {name,age,height=180}=person; 解构的本质是使用ToObject函数将元数据转为对象。\n因此，null和undefined不能被解构。\n如果给事先声明好的变量赋值，则解构表达式整个需要包裹在一对括号里。\n1）嵌套解构\n1 let {outer:{inter}}=obj; 2）部分解构\n解构像我们的对象合并一样，是尽力而为的行为，一旦解构过程发生错误，过程终止且无法回滚，也就是只解构了部分。\n3）对象解构为函数参数\n1 2 3 4 5 6 7 function sum([a, b]) { return a + b; } const numbers = [3, 5]; console.log(sum(numbers)); // 输出 8 ","date":"2023-09-16T00:00:00Z","permalink":"http://localhost:1313/p/javascript%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1/","title":"【JavaScript】理解对象"},{"content":"浮动的设计初衷 1 float: left/right/both; 浮动是网页布局最古老的方式。\n浮动一开始并不是为了网页布局而设计，它的初衷是将一个元素拉到一侧，这样文档流就能够包围它。\n常见的用途是文本环绕图片：\n浮动元素会被移出正常文档流，并被拉到容器边缘。\n清除浮动的原因及方法 浮动元素的高度不会追加到父元素上。\n如果浮动的元素比容器高，那么就可能发生容器折叠现象：\n这时，我们就需要清除浮动。\n清除浮动不太优雅的方式：在容器末尾添加一个空 div，设置 clear: both，清除两边浮动，使得容器会向下扩展包含它。\n1 \u0026lt;div style=\u0026#34;clear: both;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 既然是添加一个 div 元素，不如使用伪元素 ::after 来实现。\n1 2 3 4 5 .clearfix::after{ display: block; content: \u0026#34; \u0026#34;; clear: both; } 这个 clearfix 类是添加到包含浮动元素的元素上，而不是浮动元素本身。\n使用 display: block 的原因：默认情况下，伪元素是内联元素，而不是块级元素。为了确保伪元素占据一整行并且在浮动元素之后换行，我们需要将其设置为块级元素。更重要的是，clear 属性只对块级元素生效。\n设置 content: \u0026quot; \u0026quot; 的原因：解决一些旧版浏览器的 Bug。\n清除浮动后的另一个问题：浮动元素的外边距不会折叠到清除浮动后的容器外部，但是非浮动元素会。\n对此，解决该问题的clearfix的修改版如下：\n1 2 3 4 5 6 7 8 9 .clearfix::after, .clearfix::before{ display: table; content: \u0026#34; \u0026#34;; } .clearfix::after{ clear: both; } 为什么使用 display:table 而不是 display: block ：外边距无法通过单元格元素折叠。\n浮动陷阱：浏览器会将浮动元素尽可能地放在靠上的地方。\n如果众多的浮动元素高度不一致，最后导致布局会千变万化。哪怕是 1px 的高度差距也会导致浮动陷阱。\n解决方法：给每一行的第一个元素清除左浮动。\n假设每行有 m 个元素：\n1 2 3 .floatElement::nth-child(mn+1){ clear: left } 浮动布局示例解析：古诗欣赏 初始源代码如下：\nindex.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;古诗欣赏\u0026lt;/h1\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;main class=\u0026#34;main clearfix\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;五言绝句\u0026lt;/h3\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;media\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;media-image\u0026#34; src=\u0026#34;相思.png\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;media-body\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;相思·王维\u0026lt;/h4\u0026gt; \u0026lt;p\u0026gt; 红豆生南国，春来发几枝。 愿君多采撷，此物最相思。 \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;media\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;media-image\u0026#34; src=\u0026#34;听筝.png\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;media-body\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;听筝·李端\u0026lt;/h4\u0026gt; \u0026lt;p\u0026gt; 鸣筝金粟柱，素手玉房前。 欲得周郎顾，时时误拂弦。 \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;media\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;media-image\u0026#34; src=\u0026#34;江雪.png\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;media-body\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;江雪·柳宗元\u0026lt;/h4\u0026gt; \u0026lt;p\u0026gt; 千山鸟飞绝，万径人踪灭。 孤舟蓑笠翁，独钓寒江雪。 \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;media\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;media-image\u0026#34; src=\u0026#34;春晓.png\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;media-body\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;春晓·孟浩然\u0026lt;/h4\u0026gt; \u0026lt;p\u0026gt; 春眠不觉晓，处处闻啼鸟。 夜来风雨声，花落知多少。 \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; style.css\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 :root { box-sizing: border-box; /* 修改盒模型 */ } *, ::before, ::after { box-sizing: inherit; /* 继承 box-sizing */ } body { background-color: aliceblue; font-family: Arial, Helvetica, sans-serif; } /* 猫头鹰选择器 */ body * + *{ margin-top: 1.5em; } header{ padding: 1em 2em; background-color: antiquewhite; border-radius: .5em; margin-bottom: 2em; } .main{ padding: 0 1.5em; background-color: white; border-radius: .5em; } .container{ max-width: 800px; /* 自动适配宽度 */ margin: 0 auto; /* 双容器模式 水平居中 */ } .media{ float: left; margin: 0 1.5em 1.5em 0; /* 重置 margin */ width: calc(50% - 1.5em); /* 从宽度里减去 1.5em */ padding: 1.5em; background-color:rgb(238, 245, 247); border-radius: .5em; } .media-image{ width: 60px; height: 60px; } /* 清除浮动 */ /* .clearfix::after{ display: block; content: \u0026#34; \u0026#34;; clear: both; } */ /* 清除浮动修改版 */ .clearfix::after, .clearfix::before{ display: table; content: \u0026#34; \u0026#34;; } .clearfix::after{ clear: both; } /* 解决浮动陷阱 */ .media:nth-child(odd){ clear: left; } 效果图：\n实现图片被文字环绕 1 2 3 4 5 6 7 8 9 10 11 12 13 .media-image{ width: 100px; height: 100px; float: left; /* 左浮动 */ } .media-body{ margin-top: 0; /* 覆盖猫头鹰选择器 */ } .media-body h4{ margin-top: 0; /* 覆盖用户代理样式表 */ } 效果：\n实现图片在左文字在右 如上，图片被包含在了相邻的同级元素 media-body 中。\n如果想实现图片在左文字在右，可以为文字创建一个块级格式上下文（block formatting context，BFC）。\nBFC 将内部与外部隔绝开，内外互不影响。\n创建 BFC 的方式：\nfloat 不为 none。 overflow 不为 visible。 display 为 inline-block、table-cell、table-caption、flex、inline-flex、grid、inline-grid。 position 为 absolute 或 fixed。 网页的根元素就是一个顶级的 BFC。\nCSS 修改如下：\n1 2 3 4 5 6 7 8 9 10 11 .media-image{ width: 60px; height: 60px; float: left; margin-right: 1.5em; /* 图片与文字间增加一定间距 */ } .media-body{ margin-top: 0; /* 覆盖猫头鹰选择器 */ overflow: auto; /* 创建 BFC */ } 效果图：\n注意：使用浮动或 display: inline-block创建BFC的元素的宽度会变为 100% 。\n基于浮动实现网格系统 大部分的 CSS 框架都实现了自己的网格系统：在一个行容器内放置若干列容器，列的宽度由列容器的类决定。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;column-1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;column-1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;column-1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;column-1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;column-1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;column-1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;column-3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;column-3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 使用网格系统可以提高代码的可复用性。\n网格系统不参与行列元素的视觉样式，只负责设置宽度和定位。在行列内的元素就不必再考虑宽度和定位了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* 网格系统 */ .row::after{ display: block; content: \u0026#34; \u0026#34;; clear: both; } [class*=\u0026#34;column-\u0026#34;]{ float: left; padding: 0 0.75em; /* 左右设置内边距 */ margin-top: 0; /* 去掉顶部外边距 */ } .column-1{ width: 8.333%; } .column-2{ width: 16.6667%; } .column-3{ width: 25%; } .column-4{ width: 33.3333%; } .column-5{ width: 41.6667%; } .column-6{ width: 50%; } .column-7{ width: 58.333%; } .column-8{ width: 66.6667%; } .column-9{ width: 75%; } .column-10{ width: 83.333%; } .column-11{ width: 91.6667%; } .column-12{ width:100%; } 完整 CSS：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 :root { box-sizing: border-box; /* 修改盒模型 */ } *, ::before, ::after { box-sizing: inherit; /* 继承 box-sizing */ } body { background-color: aliceblue; font-family: Arial, Helvetica, sans-serif; } /* 猫头鹰选择器 */ body * + *{ margin-top: 1.5em; } header{ padding: 1em 2em; background-color: antiquewhite; border-radius: .5em; margin-bottom: 2em; } .main{ padding: 0 1.5em 1.5em; background-color: white; border-radius: .5em; } .container{ max-width: 800px; /* 自动适配宽度 */ margin: 0 auto; /* 双容器模式 水平居中 */ } /* 媒体对象的样式 */ .media{ padding: 1.5em; background-color:rgb(238, 245, 247); border-radius: .5em; } .media-image{ width: 60px; height: 60px; float: left; margin-right: 1.5em; } .media-body{ margin-top: 0; /* 覆盖猫头鹰选择器 */ overflow: auto; /* 创建 BFC */ } .media-body h4{ margin-top: 0; /* 覆盖用户代理样式表 */ } /* 清除浮动 */ /* .clearfix::after{ display: block; content: \u0026#34; \u0026#34;; clear: both; } */ /* 清除浮动修改版 */ .clearfix::after, .clearfix::before{ display: table; content: \u0026#34; \u0026#34;; } .clearfix::after{ clear: both; } /* 网格系统 */ .row::after{ display: block; content: \u0026#34; \u0026#34;; clear: both; } [class*=\u0026#34;column-\u0026#34;]{ float: left; padding: 0 0.75em; /* 左右设置内边距 */ margin-top: 0; /* 去掉顶部外边距 */ } .column-1{ width: 8.333%; } .column-2{ width: 16.6667%; } .column-3{ width: 25%; } .column-4{ width: 33.3333%; } .column-5{ width: 41.6667%; } .column-6{ width: 50%; } .column-7{ width: 58.333%; } .column-8{ width: 66.6667%; } .column-9{ width: 75%; } .column-10{ width: 83.333%; } .column-11{ width: 91.6667%; } .column-12{ width:100%; } 效果图如下：\n与前面的相比，这个导致了内容出现了错位，没有对齐标题。\n使用负 margin 拉伸行元素解决该问题：\n1 2 3 4 5 6 7 8 9 /* 网格系统 */ .row{ margin-left: -0.75em; margin-right: -0.75em; } ... ... 效果图：\n最终代码。\n","date":"2023-09-15T00:00:00Z","permalink":"http://localhost:1313/p/css%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/","title":"【CSS】浮动布局"},{"content":"前言 Vue 提供了多种方式来实现过渡效果。\n在CSS过渡和动画中自动应用class 配合CSS动画库 在过渡钩子函数中使用JavaScript操作DOM 配合JavaScript动画库 单元素/组件的过渡 将元素或组件放在\u0026lt;transition\u0026gt;中可以在下列情形中触发过渡效果：\n使用了v-if 使用了v-show 使用了动态组件 组件根节点 如果没有找到JavaScript过渡钩子和CSS过渡/动画，DOM操作在下一帧中立即执行。\n过渡的类名 Vue提供了6个可以自动生成的CSS类名，如下图。\n可以自动生成的类名是指给transition组件的name属性指定一个值，假设是fade，那么该name将自动扩展生成 .fade-enter、.fade-enter-active、.fade-enter-to、.fade-leave、.fade-leave-active、.fade-leave-to等上述6个类，并应用在transition组件里的过渡元素或组件上。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;style\u0026gt; .fade-enter { opacity: 0; transform: translateY(-20px); } .fade-enter-active { transition: all 0.3s ease; } .fade-enter-to { opacity: 1; transform: translateY(0); } .fade-leave { opacity: 1; } .fade-leave-active { transition: opacity 0.5s ease; } .fade-leave-to { opacity: 0; } \u0026lt;/style\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;showElement=!showElement\u0026#34;\u0026gt;显示/隐藏元素\u0026lt;/button\u0026gt; \u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;showElement\u0026#34;\u0026gt; 你好 \u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { showElement: false }, }); \u0026lt;/script\u0026gt; 自定义过渡类名 如果想结合使用animate.css动画库，可以在transition组件使用以下props来指定类名：\nenter-class enter-active-class enter-to-class leave-class leave-active-class leave-to-class 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;showElement=!showElement\u0026#34;\u0026gt;显示/隐藏元素\u0026lt;/button\u0026gt; \u0026lt;transition enter-active-class=\u0026#34;animated fadeInLeft\u0026#34; leave-active-class=\u0026#34;animated fadeOut\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;showElement\u0026#34;\u0026gt; 你好 \u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { showElement: false }, }); \u0026lt;/script\u0026gt; Animate 动画演示\n指定要监听的事件类型 通过设置transition组件的type属性来指定要监听的过渡事件类型（transitionend 和 animationend）。\ntype值可以是transition或animation。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vue 2 过渡 Demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/animate.css@3.5.1\u0026#34; rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34;\u0026gt; \u0026lt;style\u0026gt; .fade-enter { opacity: 0; transform: translateY(-20px); } .fade-enter-active { transition: all 0.3s ease; } .fade-enter-to { opacity: 1; transform: translateY(0); } .fade-leave { opacity: 1; } .fade-leave-active { transition: opacity 0.5s ease; } .fade-leave-to { opacity: 0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;toggleElement\u0026#34;\u0026gt;Toggle Element\u0026lt;/button\u0026gt; \u0026lt;transition name=\u0026#34;fade\u0026#34; type=\u0026#34;transition\u0026#34; \u0026gt; \u0026lt;div v-if=\u0026#34;showElement\u0026#34; key=\u0026#34;element\u0026#34;\u0026gt;Hello, Vue!\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;transition name=\u0026#34;bounce\u0026#34; enter-active-class=\u0026#34;animated bounceIn\u0026#34; leave-active-class=\u0026#34;animated bounceOut\u0026#34; type=\u0026#34;animation\u0026#34; \u0026gt; \u0026lt;div v-if=\u0026#34;showElement\u0026#34; key=\u0026#34;element\u0026#34;\u0026gt;Hello, vue!\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { showElement: false }, methods: { toggleElement() { this.showElement = !this.showElement; }, }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 指定过渡持续时间 默认情况下，Vue会等待过渡所在根元素的第一个transitionend或animationend事件。\n我们可以使用 transition组件上的duration prop定制一个显示的过渡持续时间，以毫秒为单位。\n1 2 3 \u0026lt;transition :duration=\u0026#34;1000\u0026#34;\u0026gt;...\u0026lt;/transition\u0026gt; \u0026lt;transition :duration=\u0026#34;{ enter: 500, leave: 800 }\u0026#34;\u0026gt;...\u0026lt;/transition\u0026gt; transition组件上的JavaScript钩子函数 共8个：\nbefore-enter enter after-enter enter-cancelled before-leave leave after-leave leave-cancelled 注意点：\n只用JavaScript过渡时，在leave和enter中必须使用done参数来告诉Vue何时过渡已经完成。 推荐对于仅使用JavaScript过渡的元素添加v-bind:css=\u0026quot;false\u0026quot;，Vue会跳过CSS的检测。这也可以避免过渡过程中CSS的影响。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vue 2 过渡 Demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/animate.css@3.5.1\u0026#34; rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34;\u0026gt; \u0026lt;!-- Velocity 和 jQuery.animate 的工作方式类似，也是用来实现 JavaScript 动画的一个很棒的选择 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;toggleElement\u0026#34;\u0026gt;切换元素\u0026lt;/button\u0026gt; \u0026lt;transition name=\u0026#34;custom-transition\u0026#34; @before-enter=\u0026#34;beforeEnter\u0026#34; @enter=\u0026#34;enter\u0026#34; @leave=\u0026#34;leave\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;showElement\u0026#34; key=\u0026#34;element\u0026#34;\u0026gt;Hello, Vue!\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { showElement: false }, methods: { toggleElement() { this.showElement = !this.showElement; }, beforeEnter(el) { // 在进入过渡开始之前调用 el.style.opacity = 0; }, enter(el, done) { // 在进入过渡的主要阶段调用 Velocity(el, { opacity: 1, translateY: \u0026#39;0px\u0026#39;,fontSize: \u0026#39;2em\u0026#39; }, { duration: 1000, complete: done }); Velocity(el, { fontSize: \u0026#39;1em\u0026#39; }, { complete: done }) }, leave(el, done) { // 在离开过渡的主要阶段调用 Velocity(el, { opacity: 0, translateY: \u0026#39;20px\u0026#39; }, { duration: 1000, complete: done }); }, } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 初始渲染的过渡 启用初始渲染的过渡：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;transition appear appear-class=\u0026#34;\u0026#34; appear-active-class=\u0026#34;\u0026#34; appear-to-class=\u0026#34;\u0026#34; v-on:before-appear=\u0026#34;\u0026#34; v-on:appear=\u0026#34;\u0026#34; v-on:after-appear=\u0026#34;\u0026#34; v-on:appear-cancelled=\u0026#34;\u0026#34; \u0026gt; \u0026lt;/transition\u0026gt; 多个元素的过渡 如果想实现多个原生元素的切换过渡，可以使用条件渲染的相关指令。\n如果切换的元素标签名相同，比如都是button，那么最好给它们设置唯一的key属性，否则可能出现过渡效果不生效或没按设置过渡的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vue 2 过渡 Demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/animate.css@3.5.1\u0026#34; rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34;\u0026gt; \u0026lt;!-- Velocity 和 jQuery.animate 的工作方式类似，也是用来实现 JavaScript 动画的一个很棒的选择 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;toggleElement\u0026#34;\u0026gt;切换元素\u0026lt;/button\u0026gt; \u0026lt;transition @before-enter=\u0026#34;beforeEnter\u0026#34; @enter=\u0026#34;enter\u0026#34; @leave=\u0026#34;leave\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;showElement\u0026#34; key=\u0026#34;el1\u0026#34;\u0026gt;Hello, girls!\u0026lt;/div\u0026gt; \u0026lt;div v-else key=\u0026#34;el2\u0026#34;\u0026gt;Hello, boys!\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { showElement: false }, methods: { toggleElement() { this.showElement = !this.showElement; }, beforeEnter(el) { // 在进入过渡开始之前调用 el.style.opacity = 0; }, enter(el, done) { // 在进入过渡的主要阶段调用 Velocity(el, { opacity: 1, translateY: \u0026#39;0px\u0026#39;,fontSize: \u0026#39;2em\u0026#39; }, { duration: 1000, complete: done }); Velocity(el, { fontSize: \u0026#39;1em\u0026#39; }, { complete: done }); }, leave(el, done) { // 在离开过渡的主要阶段调用 Velocity(el, { opacity: 0, translateY: \u0026#39;20px\u0026#39; }, { duration: 1000, complete: done }); }, } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 也可以使用绑定动态property的方式来替代使用了多个v-if的相同标签名元素。\n1 2 3 4 \u0026lt;transition\u0026gt; \u0026lt;div v-if=\u0026#34;show===\u0026#39;el1\u0026#39;\u0026#34; key=\u0026#34;el1\u0026#34;\u0026gt;el1\u0026lt;/div\u0026gt; \u0026lt;div v-if=\u0026#34;show===\u0026#39;el2\u0026#39;\u0026#34; key=\u0026#34;el2\u0026#34;\u0026gt;el2\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; 替换成\n1 2 3 \u0026lt;transition\u0026gt; \u0026lt;div :key=\u0026#34;el\u0026#34;\u0026gt;el\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; 过渡模式 如上图中，前一个元素的过渡结束时，另一个元素的过渡开始，这有时候并不是我们想要的效果。\n于是，Vue提供了过渡模式。\n1 2 \u0026lt;transition name=\u0026#34;fade\u0026#34; mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;/transition\u0026gt; mode可以为以下值：\nin-out：新元素先过渡进入，旧元素后过渡离开。 out-in：旧元素先过渡离开，新元素再过渡进入。 So cool!\n多个组件的过渡 多个元素我们可以使用key attribute，对于多个组件，我们可以使用更为简单的is attribute，即动态组件。\n1 2 3 \u0026lt;transition name=\u0026#34;component-fade\u0026#34; mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;component v-bind:is=\u0026#34;view\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/transition\u0026gt; 列表过渡 前面所讲都是针对单个节点或者多个节点中的一个。\n而对于有多个节点的列表的渲染，我们使用transition-group组件。\ntransition-group组件的特点：\n与transition不同，它以一个真实的元素存在，默认为span，可以使用tag attribute修改。 不能使用过渡模式。 列表元素都需要key attribute。 CSS过渡的类会自动应用在列表内部元素。 列表的进入/离开过渡 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vue 2 过渡 Demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/animate.css@3.5.1\u0026#34; rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34;\u0026gt; \u0026lt;!-- Velocity 和 jQuery.animate 的工作方式类似，也是用来实现 JavaScript 动画的一个很棒的选择 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;style\u0026gt; .list-enter-active, .list-leave-active { transition: opacity,transform 0.5s; } .list-enter, .list-leave-to { opacity: 0; transform: translateX(60px); } .list-item { list-style:decimal-leading-zero; margin: 5px; padding: 5px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;addItem\u0026#34;\u0026gt;Add Item\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;removeItem\u0026#34;\u0026gt;Remove Item\u0026lt;/button\u0026gt; \u0026lt;transition-group name=\u0026#34;list\u0026#34; tag=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{item.text}} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { items: [], nextItemId: 0 }, methods: { addItem() { let randomIndex=Math.floor(Math.random()*this.items.length); this.items.splice(randomIndex,0, { id: this.nextItemId++, text: `Item ${this.nextItemId}` }); }, removeItem() { let randomIndex = Math.floor(Math.random()*this.items.length); this.items.splice(randomIndex, 1); } }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 列表的排序过渡 不仅可以给进入/离开添加过渡，当列表的元素位置发生变化时，也可以产生过渡效果，通过move-classattribute自定义类名来实现，也可以使用name作为前缀。\n例如当name=\u0026quot;list\u0026quot;时：\n1 2 3 .list-move { transition: transform 1s; } 这个可以解决列表过渡不够平滑的问题。\n如果想给所有的变动都添加过渡动画，那么可以按以下方法做：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vue 2 过渡 Demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/animate.css@3.5.1\u0026#34; rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34;\u0026gt; \u0026lt;!-- Velocity 和 jQuery.animate 的工作方式类似，也是用来实现 JavaScript 动画的一个很棒的选择 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .list-enter, .list-leave-to { opacity: 0; transform: translateX(30px); } .list-leave-active{ position: absolute; } .list-item { transition: all 1s; list-style: none; margin: 5px; padding: 5px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;addItem\u0026#34;\u0026gt;Add Item\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;removeItem\u0026#34;\u0026gt;Remove Item\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;shuffleItems\u0026#34;\u0026gt;Shuffle Items\u0026lt;/button\u0026gt; \u0026lt;transition-group name=\u0026#34;list\u0026#34; tag=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{item.text}} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { items: [], nextItemId: 0 }, methods: { addItem() { let randomIndex = Math.floor(Math.random() * this.items.length); this.items.splice(randomIndex, 0, { id: this.nextItemId++, text: `Item ${this.nextItemId}` }); }, removeItem() { let randomIndex = Math.floor(Math.random() * this.items.length); this.items.splice(randomIndex, 1); }, shuffleItems() { this.items = _.shuffle(this.items); } }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这被叫做FLIP过渡，使用这种过渡方式的元素不能设置为display:inline。\n列表的交错过渡 通过 HTML 的data属性与 JavaScript 进行通信来实现交错排序。\n1 2 3 4 \u0026lt;li v-for=\u0026#34;(item, index) in computedList\u0026#34; v-bind:key=\u0026#34;item.msg\u0026#34; v-bind:data-index=\u0026#34;index\u0026#34; \u0026gt;{{ item.msg }}\u0026lt;/li\u0026gt; 1 2 3 4 5 6 7 8 9 10 enter: function (el, done) { var delay = el.dataset.index * 150; // 通过 data-index 获取元素的索引，然后计算延迟时间 setTimeout(function () { Velocity( el, { opacity: 1, height: \u0026#39;1.6em\u0026#39; }, // 使用 Velocity.js 库来应用 CSS 属性的动画效果 { complete: done } // 动画完成后调用 done 回调函数来通知 Vue.js 过渡完成 ); }, delay); }, 每个元素都有不同的延迟，以实现交错的过渡效果。\n可复用的过渡 使用template ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Vue.component(\u0026#39;my-special-transition\u0026#39;, { template: \u0026#39;\\ \u0026lt;transition\\ name=\u0026#34;reusable-transition\u0026#34;\\ mode=\u0026#34;out-in\u0026#34;\\ v-on:before-enter=\u0026#34;beforeEnter\u0026#34;\\ v-on:after-enter=\u0026#34;afterEnter\u0026#34;\\ \u0026gt;\\ \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\\ \u0026lt;/transition\u0026gt;\\ \u0026#39;, methods: { beforeEnter: function (el) { // ... }, afterEnter: function (el) { // ... } } }) 使用函数式组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Vue.component(\u0026#39;reusable-transition\u0026#39;, { functional: true, render: function (createElement, context) { var data = { props: { name: \u0026#39;reusable-transition\u0026#39;, mode: \u0026#39;out-in\u0026#39; }, on: { beforeEnter: function (el) { // ... }, afterEnter: function (el) { // ... } } } return createElement(\u0026#39;transition\u0026#39;, data, context.children) } }) 使用单文件组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;ReusableTransition\u0026#39;, }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* 在这里定义过渡的 CSS 类名和样式 */ .fade-enter-active, .fade-leave-active { transition: opacity 0.5s; } .fade-enter, .fade-leave-to /* .fade-leave-active 在版本 2.1.8 中可用 */ { opacity: 0; } \u0026lt;/style\u0026gt; 总之，可复用过渡就是以transition或transition-group作为根元素。\n动态过渡 所有过渡attribute都可以动态绑定，那么可以使用不同的过渡效果。\n而不仅仅改变过渡attribute可以进行动态过渡，在event hooks里改变组件上下文的数据也可以。\n下面是绑定name属性达到的动态过渡效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;style\u0026gt; .default-enter, .default-leave-to { opacity: 0; transform: translateX(30px); } .slide-enter, .slide-leave-to { transform: translateY(30px); opacity: 0; } .default-leave-active, .slide-leave-active{ position: absolute; } .list-item { transition: all 1s; } \u0026lt;/style\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input v-model=\u0026#34;newTodo\u0026#34; @keyup.enter=\u0026#34;addTodo\u0026#34; placeholder=\u0026#34;添加新任务\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;toggleTransition\u0026#34;\u0026gt;切换过渡方式\u0026lt;/button\u0026gt; \u0026lt;transition-group :name=\u0026#34;dynamicTransitionName\u0026#34; tag=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{todo.text}} \u0026lt;button @click=\u0026#34;removeTodo(index)\u0026#34;\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { dynamicTransitionName: \u0026#39;default\u0026#39;, newTodo: \u0026#39;\u0026#39;, todos: [], nextID: 0 }, methods: { addTodo() { if (this.newTodo.trim() !== \u0026#39;\u0026#39;) { this.todos.push({id:this.nextID++, text: this.newTodo }); this.newTodo = \u0026#39;\u0026#39;; } }, removeTodo(index) { this.todos.splice(index, 1); }, toggleTransition(){ this.dynamicTransitionName=this.dynamicTransitionName===\u0026#39;default\u0026#39;?\u0026#39;slide\u0026#39;:\u0026#39;default\u0026#39;; } }, }); \u0026lt;/script\u0026gt; 参考资料 进入/离开 \u0026amp; 列表过渡 ","date":"2023-09-12T00:00:00Z","permalink":"http://localhost:1313/p/vue-2%E8%BF%87%E6%B8%A1/","title":"【Vue 2】过渡"},{"content":"","date":"2023-09-11T00:00:00Z","permalink":"http://localhost:1313/p/javascript%E7%BB%A7%E6%89%BF/","title":"【JavaScript】继承"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rDiff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"http://localhost:1313/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"条件渲染相关的指令有哪些？\nv-if、v-else、v-else-if v-show v-if 的作用\n1 \u0026lt;div v-if=\u0026#34;expression\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; v-if 根据表达式 expression 返回的值是否为 truthy 来决定其内容是否被渲染。\nVue还实现了 v-else 和 v-else-if：\n1 2 3 \u0026lt;div v-if=\u0026#34;expression1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;expression2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt;\u0026lt;/div\u0026gt; 注意，v-else-if 须紧跟在 v-if 后，v-else须紧跟在 v-if 或 v-else-if 后。\n如果想使用 v-if 控制多个元素的渲染，可以使用 \u0026lt;template\u0026gt; 元素，因为它不会被包含在渲染结果内。\nv-if 相关源码\n首先是 src\\compiler\\parser\\index.ts ：\n处理 HTML 元素上的 if 系列指令，获取它们的表达式 exp ,如果是 v-if 指令的话，还要将其添加到它的 ifConditions 数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function processIf(el) { const exp = getAndRemoveAttr(el, \u0026#39;v-if\u0026#39;) if (exp) { el.if = exp addIfCondition(el, { exp: exp, block: el }) } else { if (getAndRemoveAttr(el, \u0026#39;v-else\u0026#39;) != null) { el.else = true } const elseif = getAndRemoveAttr(el, \u0026#39;v-else-if\u0026#39;) if (elseif) { el.elseif = elseif } } } getAndRemoveAttr 从元素中移除某个 attr ，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // note: this only removes the attr from the Array (attrsList) so that it // doesn\u0026#39;t get processed by processAttrs. // By default it does NOT remove it from the map (attrsMap) because the map is // needed during codegen. export function getAndRemoveAttr( el: ASTElement, name: string, removeFromMap?: boolean ): string | undefined { let val if ((val = el.attrsMap[name]) != null) { const list = el.attrsList for (let i = 0, l = list.length; i \u0026lt; l; i++) { if (list[i].name === name) { list.splice(i, 1) break } } } if (removeFromMap) { delete el.attrsMap[name] } return val } 以后看懂了其他源码再回来补充😉\nv-if 和 v-for一起使用时的注意点\n当 v-if 和 v-for 一起使用时，确实存在一个优先级关系：v-for 具有比 v-if 更高的优先级。这意味着 v-for 指令将首先对数据进行迭代，然后在每个迭代项上应用 v-if 条件。\n因此，如果你的本意是先进行 v-if 的判断，那么可以在循环外套个 \u0026lt;template\u0026gt; 元素，把 v-if 写在 \u0026lt;template\u0026gt; 元素上。\n使用 key attribute 阻止元素复用\n当组件需要进行重新渲染的时候，Vue 通过 diff 算法知道哪些元素可以复用以提高渲染效率。\n但是有时候，我们需要切换一个全新的子元素，就比如我们前文介绍的 v-if 系列指令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input v-if=\u0026#34;flag\u0026#34; placeholder=\u0026#34;input1\u0026#34;\u0026gt; \u0026lt;input v-else placeholder=\u0026#34;input2\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;toggleFlag\u0026#34;\u0026gt;Toggle\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data:{ flag: true }, methods:{ toggleFlag(){ this.flag=!this.flag; } } }); \u0026lt;/script\u0026gt; 上面的结果是切换 input 时会保留原来的输入数据：\n如果你有阻止这样复用的需求，那么可以给元素添加一个唯一的 key 。\n1 2 \u0026lt;input v-if=\u0026#34;flag\u0026#34; placeholder=\u0026#34;input1\u0026#34; key=\u0026#34;input1\u0026#34;\u0026gt; \u0026lt;input v-else placeholder=\u0026#34;input2\u0026#34; key=\u0026#34;input2\u0026#34;\u0026gt; v-show 的作用\nv-show 的用途和 v-if 指令一样，都是用于根据条件显示元素。\n献上 v-show 源码\nsrc\\platforms\\web\\runtime\\directives\\show.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import VNode from \u0026#39;core/vdom/vnode\u0026#39; import type { VNodeDirective, VNodeWithData } from \u0026#39;types/vnode\u0026#39; import { enter, leave } from \u0026#39;web/runtime/modules/transition\u0026#39; // recursively search for possible transition defined inside the component root function locateNode(vnode: VNode | VNodeWithData): VNodeWithData { // @ts-expect-error return vnode.componentInstance \u0026amp;\u0026amp; (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode!) : vnode } export default { bind(el: any, { value }: VNodeDirective, vnode: VNodeWithData) { vnode = locateNode(vnode) const transition = vnode.data \u0026amp;\u0026amp; vnode.data.transition const originalDisplay = (el.__vOriginalDisplay = el.style.display === \u0026#39;none\u0026#39; ? \u0026#39;\u0026#39; : el.style.display) if (value \u0026amp;\u0026amp; transition) { vnode.data.show = true enter(vnode, () =\u0026gt; { el.style.display = originalDisplay }) } else { el.style.display = value ? originalDisplay : \u0026#39;none\u0026#39; } }, update(el: any, { value, oldValue }: VNodeDirective, vnode: VNodeWithData) { /* istanbul ignore if */ if (!value === !oldValue) return vnode = locateNode(vnode) const transition = vnode.data \u0026amp;\u0026amp; vnode.data.transition if (transition) { vnode.data.show = true if (value) { enter(vnode, () =\u0026gt; { el.style.display = el.__vOriginalDisplay }) } else { leave(vnode, () =\u0026gt; { el.style.display = \u0026#39;none\u0026#39; }) } } else { el.style.display = value ? el.__vOriginalDisplay : \u0026#39;none\u0026#39; } }, unbind( el: any, binding: VNodeDirective, vnode: VNodeWithData, oldVnode: VNodeWithData, isDestroy: boolean ) { if (!isDestroy) { el.style.display = el.__vOriginalDisplay } } } locateNode 函数递归寻找当前 vnode 外层具有 transition 属性的 vnode。\n最后使用 export default 导出了一个自定义指令的配置。\n该自定义指令的bind函数的流程分析：\n首先找寻外层具有 transtion 属性的 vnode，\n1 vnode = locateNode(vnode) 保存其 transition 属性值（如果不存在为false），\n1 const transition = vnode.data \u0026amp;\u0026amp; vnode.data.transition 保存其原始的 display属性，如果本来 el.style.display 的值就为 none，那么 originalDisplay 为 空字符串''，\n1 2 const originalDisplay = (el.__vOriginalDisplay = el.style.display === \u0026#39;none\u0026#39; ? \u0026#39;\u0026#39; : el.style.display) 判断指令的绑定表达式的值及是否是过渡组件，\n如果绑定值为真值且是过渡组件，则调用 enter 函数进入过渡动画；\n如果绑定值为假值，设置元素的 display 属性为 none；\n如果绑定值是真值但不是过渡组件，设置元素的 display 属性为 originalDisplay，\n1 2 3 4 5 6 7 8 if (value \u0026amp;\u0026amp; transition) { vnode.data.show = true enter(vnode, () =\u0026gt; { el.style.display = originalDisplay }) } else { el.style.display = value ? originalDisplay : \u0026#39;none\u0026#39; } 所以，说这么多，v-show 的本质上是通过 元素的 display attribute 来控制其显示。\nv-show 和 v-if 的区别在哪里？\nv-show 本质上是切换元素的 CSS 属性 display 控制元素的可见性。\nv-if 是直接创建或销毁DOM。\n因此，频繁切换元素使用 v-show，否则使用 v-if。\n","date":"2023-09-05T00:00:00Z","permalink":"http://localhost:1313/p/vue-2%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/","title":"【Vue 2】条件渲染"},{"content":"1 nextTick的用处 vm.$netTick的作用是将回调延迟到下次DOM更新周期之后执行。\n它接受一个回调函数作为参数。\n其实，在我们更新数据状态后，是不会立马渲染的，你不能即刻获取到新的DOM：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Async Update Example\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .font-color{ color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div ref=\u0026#34;textBox1\u0026#34;\u0026gt;{{text}}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;changeText\u0026#34;\u0026gt;改变文本\u0026lt;/button\u0026gt; \u0026lt;div ref=\u0026#34;textBox2\u0026#34; :class=\u0026#34;{\u0026#39;font-color\u0026#39;: true}\u0026#34;\u0026gt;null\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { text: \u0026#34;Today is a cloudy day.\u0026#34; }, methods: { changeText() { this.text = this.text === \u0026#34;Today is a sunny day.\u0026#34; ? \u0026#34;Today is a cloudy day.\u0026#34; : \u0026#34;Today is a sunny day.\u0026#34;; this.$refs.textBox2.innerHTML = this.$refs.textBox1.innerHTML; } } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 此时，我们可以使用nextTick方法：\n1 2 3 4 5 6 7 changeText(){ this.text=this.text=== \u0026#34;Today is a sunny day.\u0026#34;? \u0026#34;Today is a cloudy day.\u0026#34;: \u0026#34;Today is a sunny day.\u0026#34;; this.$nextTick(function(){ this.$refs.textBox2.innerHTML = this.$refs.textBox1.innerHTML; }); } 如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。\n1 2 3 4 5 6 7 8 changeText(){ this.text=this.text=== \u0026#34;Today is a sunny day.\u0026#34;? \u0026#34;Today is a cloudy day.\u0026#34;: \u0026#34;Today is a sunny day.\u0026#34;; _this=this; this.$nextTick().then(function(){ _this.$refs.textBox2.innerHTML = _this.$refs.textBox1.innerHTML; }); } 测试中我们发现上面代码中then的回调参数里的this指向了window，所以我们在外面使用_this。\n2 异步更新机制 Vue侦测到数据变化时会通知到对应依赖管理器里的所有Watcher，然后虚拟DOM会对整个组件进行差异比较来更新DOM，Vue进行重新渲染。\n如果我在一个循环中不停改变一个数据属性，那对应的Watcher就会收到多份通知，是不是要进行多次渲染呢？\n明显不会，Vue.js会将收到的watcher实例添加到异步更新队列中，且不会重复添加同一个watcher，然后等到下一次事件循环，一次性清空队列里的所有watcher并让它们触发渲染。\n3 事件循环 3.1 什么是事件循环 前面提到的事件循环又是什么？\n我们知道，JavaScript是一门单线程且非阻塞的语言。\n单线程意味着一次只能执行一个任务，也叫做主线程。\n非阻塞意味着遇到异步任务（比如网络请求、文件读取、定时器等）时，JavaScript会将这些异步任务挂起，继续执行后面的代码。当异步任务处理完毕后，根据一定的规则（通常是回调函数或Promise）来处理操作的结果。\n挂起（pending）是指将异步任务放入一个队列里，称为事件队列。\n而异步任务可以分为微任务和宏任务。\n微任务放在微任务队列，宏任务放在宏任务队列。\n当主线程执行栈的任务都执行完后，检查微任务队列，执行微任务的回调事件，直到微任务队列为空，再检查宏任务队列，从中选出一个事件，将其回调加入执行栈，重复上述步骤。\n这也就是事件循环。\n3.1 常见微任务 1）Promise的then、catch和finally\n当一个Promise的状态从pending变为fulfilled或reject时，与之相关的then或catch回调就会被添加到微任务队列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 console.log(\u0026#34;开始\u0026#34;); // 创建一个Promise对象 const myPromise = new Promise((resolve, reject) =\u0026gt; { console.log(\u0026#34;Promise中的同步代码\u0026#34;); resolve(\u0026#34;Promise成功\u0026#34;); // 模拟成功情况 }); // 添加then、catch和finally回调 myPromise .then((result) =\u0026gt; { console.log(\u0026#34;then回调执行:\u0026#34;, result); }) .catch((error) =\u0026gt; { console.error(\u0026#34;catch回调执行:\u0026#34;, error); }) .finally(() =\u0026gt; { console.log(\u0026#34;finally回调执行\u0026#34;); }); console.log(\u0026#34;Promise后的同步代码\u0026#34;); // 模拟宏任务 setTimeout(() =\u0026gt; { console.log(\u0026#34;宏任务回调执行\u0026#34;); }, 0); console.log(\u0026#34;结束\u0026#34;); 输出\n1 2 3 4 5 6 7 开始 Promise中的同步代码 Promise后的同步代码 结束 then回调执行: Promise成功 finally回调执行 宏任务回调执行 2）async/await\nawait后面的表达式会生成一个微任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 console.log(\u0026#34;开始\u0026#34;); // 模拟一个异步函数，返回一个Promise async function fetchData() { console.log(\u0026#34;异步函数内部的同步代码\u0026#34;); return \u0026#34;Promise成功\u0026#34;; // 模拟成功情况 } // 使用async/await来处理异步操作 async function processData() { try { const result = await fetchData(); // 等待Promise解决 console.log(\u0026#34;成功:\u0026#34;, result); } catch (error) { console.error(\u0026#34;失败:\u0026#34;, error); } finally { console.log(\u0026#34;finally回调执行\u0026#34;); } } // 调用async函数 processData(); console.log(\u0026#34;异步函数后的同步代码\u0026#34;); // 模拟宏任务 setTimeout(() =\u0026gt; { console.log(\u0026#34;宏任务回调执行\u0026#34;); }, 0); console.log(\u0026#34;结束\u0026#34;); 输出\n1 2 3 4 5 6 7 开始 异步函数内部的同步代码 异步函数后的同步代码 结束 成功: Promise成功 finally回调执行 宏任务回调执行 3）MutationObserver回调\nMutationObserver是一个监视DOM树变化的API。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;MutationObserver示例\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .text{ color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;target\u0026#34;\u0026gt; \u0026lt;p\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 选择要监视的目标元素 const target = document.getElementById(\u0026#39;target\u0026#39;); // 创建一个MutationObserver实例，传入回调函数 const observer = new MutationObserver(function (mutationsList, observer) { // 遍历变化列表中的每个MutationRecord for (let mutation of mutationsList) { if (mutation.type === \u0026#39;childList\u0026#39;) { // 子节点变化 console.log(\u0026#39;子节点变化：\u0026#39;, mutation.addedNodes, mutation.removedNodes); } else if (mutation.type === \u0026#39;attributes\u0026#39;) { // 属性变化 console.log(\u0026#39;属性变化：\u0026#39;, mutation.target.className, mutation.oldValue); } } }); // 配置MutationObserver选项，监视子节点变化 const config = { childList: true, attributes: true, subtree: true, characterData: true }; // 开始观察目标元素 observer.observe(target, config); // 在一段时间后，修改目标元素，观察变化 setTimeout(function () { target.innerHTML = \u0026#39;\u0026lt;p\u0026gt;这是一个新的段落。\u0026lt;/p\u0026gt;\u0026#39;; }, 1000); // 属性变化 setTimeout(function () { target.classList.add(\u0026#39;text\u0026#39;) }, 2000); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4）process.nextTick\nnode.js中进程相关的对象\n1 2 3 4 5 console.log(\u0026#39;这是第一个任务\u0026#39;); process.nextTick(function() { console.log(\u0026#39;这是下一个微任务\u0026#39;); }); console.log(\u0026#39;这是第二个任务\u0026#39;); 5）queueMicrotask\n这是一个ECMAScript 2020引入的方法。\n1 2 3 queueMicrotask(function() { // 这是一个微任务 }); 3.2 常见宏任务 1）定时器任务，如setTimeout或setInterval\n2）网络请求。\n1 2 3 4 5 6 7 8 const xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;https://example.com/api/data\u0026#39;, true); xhr.onreadystatechange = function() { if (xhr.readyState === 4 \u0026amp;\u0026amp; xhr.status === 200) { console.log(\u0026#39;网络请求完成\u0026#39;); } }; xhr.send(); 3）DOM操作，对DOM元素进行操作，例如添加、删除、修改元素。\nDOM操作可能会导致页面的重新渲染和重排（reflow），这些操作是昂贵的，需要消耗较多的计算资源，因此它们通常被视为宏任务，而不是微任务。\n你可以考虑使用 requestAnimationFrame 或其他微任务机制来优化DOM操作的性能。\n4）文件操作\n1 2 3 4 5 const fs = require(\u0026#39;fs\u0026#39;); fs.readFile(\u0026#39;example.txt\u0026#39;, \u0026#39;utf8\u0026#39;, function(err, data) { if (err) throw err; console.log(\u0026#39;读取文件完成\u0026#39;); }); 4 nextTick源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import { noop } from \u0026#39;shared/util\u0026#39; import { handleError } from \u0026#39;./error\u0026#39; import { isIE, isIOS, isNative } from \u0026#39;./env\u0026#39; //指示是否正在使用微任务来处理异步操作 export let isUsingMicroTask = false //存储待执行的回调函数 const callbacks: Array\u0026lt;Function\u0026gt; = [] //是否有待执行的回调 let pending = false //用于执行回调函数。它将 callbacks 数组中的回调函数依次执行，并在执行后清空 callbacks 数组 function flushCallbacks() { pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i \u0026lt; copies.length; i++) { copies[i]() } } //根据环境选择使用微任务或宏任务来执行回调函数 let timerFunc //如果浏览器支持原生的 Promise，则使用 Promise 来实现微任务。 if (typeof Promise !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; isNative(Promise)) { const p = Promise.resolve() timerFunc = () =\u0026gt; { p.then(flushCallbacks) //在 iOS 上使用 UIWebView 时，添加一个空的 setTimeout(noop) 来强制刷新微任务队列 if (isIOS) setTimeout(noop) } isUsingMicroTask = true } else if ( !isIE \u0026amp;\u0026amp; typeof MutationObserver !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; (isNative(MutationObserver) || MutationObserver.toString() === \u0026#39;[object MutationObserverConstructor]\u0026#39;) ) {//如果浏览器不支持原生 Promise，但支持 MutationObserver，则使用 MutationObserver 来实现微任务 let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, { characterData: true }) //这种情况下，timerFunc 将观察一个文本节点的字符数据变化来触发回调函数的执行 timerFunc = () =\u0026gt; { counter = (counter + 1) % 2 textNode.data = String(counter) } isUsingMicroTask = true } else if (typeof setImmediate !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; isNative(setImmediate)) { timerFunc = () =\u0026gt; { setImmediate(flushCallbacks) } } else { timerFunc = () =\u0026gt; { setTimeout(flushCallbacks, 0) } } ","date":"2023-09-03T00:00:00Z","permalink":"http://localhost:1313/p/vue-2nexttick%E6%96%B9%E6%B3%95%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","title":"【Vue 2】nextTick方法、异步更新、事件循环"},{"content":"1 前言 水平居中、垂直居中是前端面试百问不厌的问题。\n其实现方案也是多种多样，常叫人头昏眼花。\n水平方向可以认为是内联方向，垂直方向认为是块级方向。\n下面介绍一些常见的方法。\n1 2 3 \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;innerText\u0026#34;\u0026gt;Hello,World!\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 2 内联元素的水平垂直居中 首先，常见内联元素有：a、span、em、b、strong、i、button。\n2.1 使用弹性布局 使用dispaly: flex将父级容器设置为弹性布局（Flexbox），然后可以通过justify-content: center控制水平居中，使用align-items: center控制垂直居中。\n1 2 3 4 5 6 7 8 9 10 .container { height: 100px; width: 200px; background-color: cadetblue; display: flex; /* 水平居中 */ justify-content: center; /* 垂直居中 */ align-items: center; } 2.2 使用网格布局 使用dispaly: grid将父级容器设置为网格布局（Grid），然后可以通过place-items: center;控制水平垂直居中。\n1 2 3 4 5 6 7 .container { height: 100px; width: 200px; background-color: antiquewhite; display: grid; place-items: center; } place-items是align-items、justify-items的简写。\n2.3 使用text-align和line-hight 设置父级容器的text-align: center实现文本水平居中对齐，关键的一步设置行高line-height为容器的高度即可实现文本垂直居中。\n为什么设置行高line-height为容器的高度就能实现文本垂直居中？\n因为文本的基线位于行高的中间，基线也是文本的中线，设置行高等于高度后，文字就垂直居中了。\n1 2 3 4 5 6 7 8 9 .container { height: 100px; width: 200px; background-color: antiquewhite; /* 水平居中 */ text-align: center; /* 垂直居中，行高等于高度 */ line-height: 100px; } 2.4 使用text-align和display: table-cell 将元素设置为表格单元格，再使用vertical-align: center实现垂直居中。\n1 2 3 4 5 6 7 8 9 10 .container { height: 100px; width: 200px; background-color: antiquewhite; display: table-cell; /* 水平居中 */ text-align: center; /* 垂直居中 */ vertical-align: middle; } 3 块级元素的水平垂直居中 常见块级元素有：h1-h6、p、div、ul、ol、li等。\n1 2 3 \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;innerText\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 前面介绍的内联元素的水平垂直居中方法也适用于块级元素。下面就不再重复介绍。\n3.1 绝对定位+margin: auto 首先，设置父元素为相对定位。\n为什么要设置父元素为相对定位？\n创建一个提供给子元素的定位坐标系，使得子元素在该坐标系内定位。 绝对定位的元素会脱离正常文档流，并相对于最近的已定位组件进行定位。 margin: auto计算居中位置依赖于外部的相对定位的父元素。 设置子元素为绝对定位，其top、left、right、bottom的值设为0，margin为auto即可让子元素自动调整四周距离一样实现水平垂直居中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 .container { height: 100px; width: 200px; background-color: cadetblue; position: relative; } .innerText { background-color: black; position: absolute; top: 0; left: 0; bottom: 0; right: 0; width: 50px; height: 50px; /* 水平垂直居中 */ margin: auto; } 3.2 绝对定位+负margin 除了自动计算，我们还可以根据长宽手动指定元素移动距离。\n使用负margin值实现元素的平移。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .container { height: 100px; width: 200px; background-color: cadetblue; position: relative; } .innerText { width: 50px; height: 50px; background-color: black; position: absolute; top: 50%; left: 50%; margin: -25px 0 0 -25px; } 3.3 绝对定位+transform 使用transform实现元素的平移。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .container { height: 100px; width: 200px; background-color: cadetblue; position: relative; } .innerText { width: 50px; height: 50px; background-color: black; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); } ","date":"2023-09-02T00:00:00Z","permalink":"http://localhost:1313/p/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88/","title":"【CSS】水平垂直居中方案"},{"content":"1 前言 CSS过渡(transition)可以在一个元素切换到另一种状态时为其定义平滑的过渡效果。\n例如，用户鼠标悬停在按钮上时，按钮颜色平滑的从一个颜色过渡到另一个颜色。\n1 2 3 4 .btn:hover{ background-color: red; color: black; } 默认悬停效果\n添加过渡效果\n1 2 3 4 .btn{ transition-duration: 0.8s; transition-timing-function: ease; } transition是transition-property、transition-duration、transition-timing-function、transition-delay的简写属性。\n下面来一一介绍这些属性。\n2 transition-property 这个属性指定应用过渡效果的属性名。\n它有以下取值：\nall：默认值，表示过渡效果应用到所有可过渡的属性上。 none：没有过渡动画。 \u0026lt;property-name\u0026gt;：指定应用过渡效果的属性名，你可以指定多个值，使用逗号分隔。 initial：重置为初始值。 unet：重置为默认值。 3 transition-duration 过渡周期，过渡效果的持续时间。\n默认值为0s，即没有过渡效果。\n属性值以秒或毫秒为单位，像transition-property一样，你也可以设置多个值，它们会自动对应transition-property指定的属性名。\n如果时间周期数小于过渡属性数，那么周期数会重复应用；如果时间周期数大于过渡属性数，那么时间周期数多余的部分被忽略。\n4 transition-timing-function 过渡效果的时间函数，决定了动画变化速度。\n下面是它的属性值介绍。\n1）ease\n默认值。\n过渡在开始时速度较慢，中间时加速，结束时减速。\n2）ease-in\n过渡开始时速度较慢，然后逐渐加速。\n3）ease-out\n开始时速度较快，然后逐渐减速。\n4）ease-in-out\n过渡开始和结束时速度较慢，中间时速度较快。相比于ease更加平滑。\n5）linear\n过渡速度恒定，没有加速或减速，呈线性变化。\n6）step-start\n在过渡的开始时立即跳到结束状态。\n7）step-end\n在过渡的结束时立即跳回开始状态。\n8）steps函数\n例如steps(4,jump-end)表示将过渡划分为4步，每一步结束时立即跳到结束状态。\n第二个参数有以下值：\njump-start：在每一步开始时立即跳到结束状态。 jump-end：在每一步结束时立即跳到结束状态。 jump-none：没有跳跃，过渡效果平滑进行。 jump-both：在每一步的开始和结束时都立即跳到结束状态。 9）cubic-bezier函数\n接受四个参数，分别定义了时间曲线上的两个控制点。\n这四个参数的取值范围是从0到1之间。\n这四个参数的组合决定了贝塞尔曲线的形状，从而影响了过渡效果的速度和变化。\n你可以使用在线的贝塞尔曲线生成器来可视化和调整这些参数。\n5 transition-delay 过渡之前需要等待的时间。\n6 移动小球Demo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;移动小球Demo\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { margin: 0; padding: 0; } .ball{ position: absolute; width: 50px; height: 50px; border-radius: 50px; background-color: red; transition:all 7s ease; } .move { transform: translateX(300px); /* 将小球向右移动 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;animateButton\u0026#34;\u0026gt;移动\u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;ball\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const animateButton = document.getElementById(\u0026#34;animateButton\u0026#34;); const ball = document.querySelector(\u0026#34;.ball\u0026#34;); animateButton.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { ball.classList.toggle(\u0026#34;move\u0026#34;); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2023-09-01T00:00:00Z","permalink":"http://localhost:1313/p/csstransition/","title":"【CSS】transition"},{"content":"JavaScript 执行上下文 执行上下文决定了变量和函数可以访问哪些数据，即代码执行的环境。\n一个执行上下文就对应一个仅后台可访问的变量对象，其中保存有该上下文的局部变量、参数和函数声明。\n每个执行上下文都有自己的生命周期，当代码执行完成后，执行上下文会被销毁。\n最外层的上下文称为全局上下文。宿主环境不同，全局上下文的关联对象就不同。在浏览器中，全局上下文就是window对象。\n注意window后没有s。\n除了 window 对象自带的属性外，使用var定义的全局变量和函数都会成为其属性。\nvar具有函数作用域，let和const具有块级作用域。\n1 2 3 4 5 6 7 var a1=1; function func(){ var a2=2; } console.log(a1); //输出1 console.log(typeof a2 === \u0026#34;undefined\u0026#34;); //输出true console.log(window.a1); //输出1 window.a1也可以写成window['a1']。\n一般的上下文在其代码执行完后就销毁，而全局上下文是在程序退出时才被销毁。\n执行上下文会按照函数的调用顺序形成一个堆栈，称为执行上下文栈。\n当前执行上下文位于执行上下文栈的顶端，当它执行完后会被弹出，程序的控制权就交给之前的上下文。\n我们用到的、见到的this指针指向的就是这个当前执行上下文，其值取决于函数的调用方式。\n作用域链 作用域链（scope chain）决定了变量和函数的访问权限和顺序，这个链的最前端是当前执行上下文的变量对象。\n作用域链的先后顺序就是内外顺序，内部执行上下文包含了外部执行上下文。换句话说，内部执行上下文可以访问外部执行上下文。\n我们访问变量和函数的顺序就是从作用域链的前面往后面找。\n看个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const a4=4; var a5=5; const func1 = function (a3) { const a2=2; function func2() { const a1=1; return function func3(){ console.log(a1+a2+a3+a4+a5); } }; return func2(); }; const result=func1(3); result(); [[Scopes]]记录的是变量的父作用域链，可以看到result并没有func3的上下文。\n作用域链增强 有两个影响作用域链的行为：with和try/catch的catch块。\n使用with将指定对象的作用域推入上下文栈：\n1 2 3 4 5 6 7 let person={ name:\u0026#39;Carl\u0026#39;, age:22 } with(person){ console.log(name+\u0026#34;\u0026#39;s age is \u0026#34;+age); } try/catch语句的catch块是一个单独的上下文，捕获的错误信息被添加到catch块的变量对象上，于是只能在catch块访问该错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 try { // 可能会引发异常的代码 const result = someFunction(); } catch (error) { // 捕获异常并处理 console.error(\u0026#34;An error occurred:\u0026#34;, error.name, error.message); // 在 catch 块内部可以定义局部变量 const errorCode = 500; console.log(\u0026#34;Error code:\u0026#34;, errorCode); } // 在这里无法访问 error 和 errorCode console.log(error); // 抛出 ReferenceError console.log(errorCode); // 抛出 ReferenceError ","date":"2023-08-29T00:00:00Z","permalink":"http://localhost:1313/p/javascript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/","title":"【JavaScript】执行上下文与作用域链"},{"content":"for in for in 语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性。\n一个属性可不可枚举是由它的内部属性[[Enumerable]]决定的。\n获取对象元素的属性描述：\n1 Object.getOwnPropertyDescriptor(obj,prop); 返回值是一个对象，包含以下属性：\nconfigurable：是否可配置 enumerable：是否可枚举 value：属性值 writable：是否可写 1 2 3 4 5 6 const obj = {a:1,b:2,c:3}; const propDesc = Object.getOwnPropertyDescriptor(obj,\u0026#39;a\u0026#39;); for(const prop in propDesc){ console.log(prop); } console.log(proDesc.enumerable); 输出：\n1 2 3 4 5 value writable enumerable configurable true 实际上for in遍历的是键名，而不是键值。\n因为对象的属性是没有顺序的，所以for in语句以任意顺序遍历对象的属性。\nfor in语句会遍历对象及其原型链上的所有可枚举属性。\n1 2 3 4 5 6 7 const obj = {a:1,b:2,c:3}; const obj2 = Object.create(obj); obj2.d = 4; for(const prop in obj2){ console.log(prop); } //输出：d a b c for in语句会遍历数组的索引，而不是数组元素。\n1 2 3 4 5 const arr = [1,2,3]; for(const index in arr){ console.log(index); } //输出：0 1 2 for of for of语句用于遍历可迭代对象的元素。\n可迭代对象包括Array，Map，Set，String，TypedArray，arguments对象等等。\n元素指的是数组的值，Map的键值对，Set的值，String的字符等等。\n可迭代对象的判断：\n1 2 3 function isIterable(obj){ return obj!=null\u0026amp;\u0026amp;typeof obj[Symbol.iterator]===\u0026#39;function\u0026#39;; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const arr = [1,2,3]; for(const value of arr){ console.log(value); } //输出：1 2 3 const map = new Map().set(\u0026#39;a\u0026#39;,1).set(\u0026#39;b\u0026#39;,2).set(\u0026#39;c\u0026#39;,3); for(const value of map){ console.log(value); } //输出：[\u0026#34;a\u0026#34;, 1] [\u0026#34;b\u0026#34;, 2] [\u0026#34;c\u0026#34;, 3] const set = new Set().add(1).add(2).add(3); for(const value of set){ console.log(value); } //输出：1 2 3 const str = \u0026#39;abc\u0026#39;; for(const value of str){ console.log(value); } //输出：a b c ","date":"2023-08-28T00:00:00Z","permalink":"http://localhost:1313/p/javascriptfor-in%E5%92%8Cfor-of%E8%AF%AD%E5%8F%A5/","title":"【JavaScript】for in和for of语句"},{"content":"JavaScript的数组是动态的，其长度可以随时改变，而且可以存储任意类型的数据。\nlength属性 数组的长度，可以通过该属性改变数组的长度。\n用途：arr.length-1→arr的最后一个元素被删除。\n创建数组 常用创建数组的方法：\n1 2 3 4 5 6 let arr=new Array(19); //创建一个长度为19的数组 let arr=new Array(1,2,3); //创建一个包含1,2,3的数组 let arr=[1,2,3]; //创建一个包含1,2,3的数组 let arr=[]; //创建一个空数组 let arr=[1,2,]; //最后一个逗号会被忽略 let arr=[1,,3]; //中间的空位会被当做undefined ES6新增了两个创建数组的方法：Array.from()和Array.of()。\nArray.from Array.from()将以下类型的对象转为数组：\n类数组对象，即可迭代对象。 拥有一个length属性和可索引元素的对象。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //字符串转数组 console.log(Array.from(\u0026#34;Hello\u0026#34;)); //[\u0026#34;H\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;o\u0026#34;] //Map和Set转数组 let map=new Map().set(\u0026#34;a\u0026#34;,1).set(\u0026#34;b\u0026#34;,2); console.log(Array.from(map)); //[[\u0026#34;a\u0026#34;, 1], [\u0026#34;b\u0026#34;, 2]] let set=new Set().add(\u0026#34;a\u0026#34;).add(\u0026#34;b\u0026#34;); console.log(Array.from(set)); //[\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;] //浅复制数组 let arr=[1,2,3]; console.log(Array.from(arr)); //[1, 2, 3] //可迭代对象转数组 let iter={ *[Symbol.iterator](){ yield 1; yield 2; yield 3; } } console.log(Array.from(iter)); //[1, 2, 3] //arguments对象转数组 function fn(){ console.log(Array.from(arguments)); } console.log(fn(1,2,3)); //[1, 2, 3] //带有length属性和可索引元素的对象转数组 let obj={ length:3, 0:1, 1:2, 2:3 } console.log(Array.from(obj)); //[1, 2, 3] Array.from()第二个参数是一个映射函数，可以直接增强新数组的值，而无需像Array().from().map()方法那样先创建一个中间数组。\n1 2 let arr=[1,2,3]; console.log(Array.from(arr,x=\u0026gt;x*2)); //[2, 4, 6] Array.of Array.of方法可将一参数数组转为数组。\n1 2 3 4 function fn() { console.log(Array.of(...arguments)); } fn(1, 2, 3); //[1, 2, 3] Array.of(5)与Array(5)会产生一样的结果吗？\n检测数组 检测数组的方法：\n1 2 3 let arr=[1,2,3]; arr instanceof Array //true Array.isArray(arr) //true 使用instanceof检测数组的问题在于，如果数组是在另一个全局执行环境（比如不同的窗口或框架）中创建的，那么instanceof就会返回false。\n设计一个Demo看看情况：\nindex.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let iframe=document.createElement(\u0026#39;iframe\u0026#39;); iframe.src=\u0026#39;child-iframe.html\u0026#39;; iframe.onload=function(){ let arrInChild=iframe.contentWindow.arrInChild; console.log(arrInChild); console.log(arrInChild instanceof Array); console.log(Array.isArray(arrInChild)); } document.body.appendChild(iframe); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; child-iframe.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Child IFrame\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; var arrInChild = [1, 2, 3, 4, 5]; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在控制台中可以看到：\narrChild是在child-iframe.html中定义的，尽管使用了var声明，instanceof依然无法检测其是否是数组，而使用Array.isArray则生效。\n如果使用let声明arrInChild，则会报错说arrInChild未定义。\n迭代器方法 ES6新增了三个迭代器方法：keys()、values()和entries()。\nkeys()：返回一个包含数组中每个索引键的迭代器。 values()：返回一个包含数组中每个索引值的迭代器。 entries()：返回一个包含数组中每个索引键值对的迭代器。 1 2 3 4 5 6 7 8 9 let arr=[1,2,3]; console.log(arr.keys()); //[0, 1, 2] console.log(arr.values()); //[1, 2, 3] console.log(arr.entries()); //[[0, 1], [1, 2], [2, 3]] // for...of循环+解构 for(let [index,value] of arr.entries()){ console.log(index,value); } 复制和填充方法 ES6新增了两个复制和填充方法：copyWithin()和fill()。\n1.fill() 使用指定值填充数组的指定位置。\nfill(value,start,end)：将[start,end)的位置替换为value。\n如果没有指定start和end，默认填充所有位置。 如果只指定start，则end为数组末尾。 1 2 3 4 5 6 7 8 9 10 let arr=[1,2,3]; arr.fill(5); console.log(arr); //[5, 5, 5] arr.fill(6,1); console.log(arr); //[5, 6, 6] arr.fill(7,1,2); console.log(arr); //[5, 7, 6] 2.copyWithin() 从数组内部复制一段内容到数组其他位置，会覆盖原有成员。\ncopyWithin(target,start,end)：将[start,end)位置的内容复制到target。\n1 2 3 4 5 6 7 8 9 10 11 12 13 let arr=[1,2,3,4,5]; //将数组中索引从0开始的元素复制到索引从1开始的位置 arr.copyWithin(1); console.log(arr); //[1, 1, 2, 3, 4] //将数组中索引 [1,arr.length) 的元素复制到索引从2开始的位置 arr.copyWithin(2,1); console.log(arr); //[1, 1, 1, 2, 3] //将数组中索引 [1,3) 的元素复制到索引从2开始的位置 arr.copyWithin(2,1,3); console.log(arr); //[1, 1, 1, 1, 3] 转换方法 toString()：将数组转换为字符串，每个元素用逗号分隔。对每个元素调用toString()方法。\ntoLocaleString()：将数组转换为字符串，每个元素用逗号分隔，使用本地特定的分隔符。对每个元素调用toLocaleString()方法。\nvalueOf()：返回数组本身。\njoin()：将数组转换为字符串，每个元素用指定的分隔符分隔。\n1 2 3 4 5 6 let arr=[1,2,3]; console.log(arr.toString()); //1,2,3 console.log(arr.toLocaleString()); //1,2,3 console.log(arr.valueOf()); //[1, 2, 3] console.log(arr.join()); //1,2,3 console.log(arr.join(\u0026#39;-\u0026#39;)); //1-2-3 如果数组中的某个元素是null或undefined，那么该元素在join()、toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示。\n栈方法 ECMAScript数组提供了一些方法，可以让数组像栈一样工作。\npush()：将_一个或多个_元素添加到数组的末尾，返回数组的新长度。 pop()：删除数组的最后一个元素，返回该元素。 1 2 3 4 5 let arr=[1,2,3]; console.log(arr.push(4,5)); //5 console.log(arr); //[1, 2, 3, 4, 5] console.log(arr.pop()); //5 console.log(arr); //[1, 2, 3, 4] 队列方法 ECMAScript数组也提供了一些方法，可以让数组像队列一样工作。\nshift()：删除数组的第一个元素，返回该元素。\nunshift()：将_一个或多个_元素添加到数组的开头，返回数组的新长度。\n1 2 3 4 5 let arr=[1,2,3]; console.log(arr.shift()); //1 console.log(arr); //[2, 3] console.log(arr.unshift(4,5)); //4 console.log(arr); //[4, 5, 2, 3] 排序方法 数组有两个排序方法：reverse()和sort()。\nreverse()：反转数组的顺序。\nsort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。接受一个比较函数作为参数，用于指定按照什么顺序排列。\n1 2 3 4 let arr=[1,2,3]; console.log(arr.reverse()); //[3, 2, 1] console.log(arr.sort()); //[1, 2, 3] console.log(arr.sort((a,b)=\u0026gt;b-a)); //[3, 2, 1] 操作方法 1.concat() 先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。\n1 2 3 4 let arr=[1,2,3]; console.log(arr.concat(4,5)); //[1, 2, 3, 4, 5] console.log(arr.concat(4,[5,6])); //[1, 2, 3, 4, 5, 6] console.log(arr.concat([4,[5,6]])); //[1, 2, 3, 4, [5, 6]] concat()默认打平一层。\n设置Symbol.isConcatSpreadable为false可以阻止concat()打平。\n1 2 3 4 let arr = [1, 2, 3]; let arr2 = [4, 5]; arr2[Symbol.isConcatSpreadable] = false; console.log(arr.concat(arr2)); //[1, 2, 3, [4, 5]] 2.slice() 基于当前数组中的一个或多个项创建一个新数组。接收两个参数：要返回项的起始位置和结束位置。返回项包括起始位置，但不包括结束位置。\n1 2 3 4 5 let arr=[1,2,3,4,5]; console.log(arr.slice(1)); //[2, 3, 4, 5] console.log(arr.slice(1,3)); //[2, 3] console.log(arr.slice(-2)); //[4, 5] console.log(arr.slice(-2,-1)); //[4] 3.splice() 删除、插入和替换数组的元素，非常强大。接收三个参数：要删除的第一项的位置、要删除的项数和要插入的项。返回值是一个由删除项组成的数组。\n1 2 3 4 5 6 7 let arr=[1,2,3,4,5]; console.log(arr.splice(1,2)); //[2, 3] console.log(arr); //[1, 4, 5] console.log(arr.splice(1,0,2,3)); //[] console.log(arr); //[1, 2, 3, 4, 5] console.log(arr.splice(1,2,6,7)); //[2, 3] console.log(arr); //[1, 6, 7, 4, 5] 位置方法 Ⅰ.按严格相等搜索 严格相等搜索即使用全等符===进行比较。\nindexOf()：从数组的开头（位置0）开始向后查找，返回要查找的项在数组中的位置；如果没找到，返回-1。\nlastIndexOf()：从数组的末尾开始向前查找，返回要查找的项在数组中的位置；如果没找到，返回-1。\nincludes()：从数组的开头（位置0）开始向后查找，返回一个布尔值，表示是否包含给定的值。\n1 2 3 4 let arr=[1,2,3,4,5,4,3,2,1]; console.log(arr.indexOf(3)); //2 console.log(arr.lastIndexOf(3)); //6 console.log(arr.includes(3)); //true Ⅱ.按回调函数搜索 find()：找到第一个返回值为true的项，然后返回该项。如果没找到，返回undefined。 findIndex()：找到第一个返回值为true的项，然后返回该项的索引。如果没找到，返回-1。 1 2 3 let arr=[1,2,3,4,5]; console.log(arr.find((value,index,arr)=\u0026gt;value\u0026gt;3)); //4 console.log(arr.findIndex((value,index,arr)=\u0026gt;value\u0026gt;3)); //3 迭代方法 forEach()：对数组中的每一项运行给定函数，没有返回值。 map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。 some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。 他们的参数格式一致：回调函数、可选的执行上下文对象。\n回调函数接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let arr=[1,2,3,4,5]; arr.forEach((value,index,arr)=\u0026gt;console.log(value,index,arr)); //1 0 [1, 2, 3, 4, 5] //2 1 [1, 2, 3, 4, 5] //3 2 [1, 2, 3, 4, 5] //4 3 [1, 2, 3, 4, 5] //5 4 [1, 2, 3, 4, 5] console.log(arr.map((value,index,arr)=\u0026gt;value*2)); //[2, 4, 6, 8, 10] console.log(arr.filter((value,index,arr)=\u0026gt;value\u0026gt;3)); //[4, 5] console.log(arr.every((value,index,arr)=\u0026gt;value\u0026gt;3)); //false console.log(arr.some((value,index,arr)=\u0026gt;value\u0026gt;3)); //true forEach回调函数中的this指向是？如何退出forEach?\n1 2 3 4 5 6 7 (function foo() { let arr = [1, 2, 3, 4, 5] arr.forEach((value, index, arr) =\u0026gt; { console.log(this) //window throw Error(\u0026#39;退出forEach\u0026#39;) }) }()) 归并方法 归并方法：reduce()和reduceRight()。\nreduce()：从数组的第一项开始，逐个遍历到最后。 reduceRight()：从数组的最后一项开始，逐个遍历到第一项。 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。\n传给reduce()和reduceRight()的函数接收四个参数：前一次reduce的返回值、当前值、当前项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。\n1 2 3 let arr=[1,2,3,4,5]; console.log(arr.reduce((prev,cur,index,arr)=\u0026gt;prev+cur)); //15 console.log(arr.reduce((prev,cur,index,arr)=\u0026gt;prev+cur,10)); //25 ","date":"2023-08-28T00:00:00Z","permalink":"http://localhost:1313/p/javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/","title":"【JavaScript】数组方法"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"http://localhost:1313/p/image-gallery/2_hubce42636ecacc1a380b462f3110efcec_37455_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/image-gallery/","title":"Image gallery"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"http://localhost:1313/p/shortcodes/cover_huec3c3e34981507583e214021ad1b9a4b_12942_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/shortcodes/","title":"Shortcodes"},{"content":"background属性为元素添加背景效果。\n它是以下属性的简写，按顺序为：\nbackground-color background-image background-repeat background-position background-size background-origin background-clip background-attachment 1 2 3 .element { background: #ff0000 url(\u0026#39;background.jpg\u0026#39;) no-repeat top right / 200px 150px content-box border-box fixed; } 以下所有示例中的花花.jpg图片的大小是48×48。\n1 background-color background-color指定元素的背景色。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;CSS 背景色 Demo\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { margin: 0; padding: 0; } .container { width: 200px; height: 200px; background-color: #f0f0f0; } .box { width: 100px; height: 100px; background-color: #f00; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2 background-image 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;CSS 背景图片 Demo\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { margin: 0; padding: 0; } .bg { width: 96px; height: 96px; background-image: url(\u0026#39;./花花.jpg\u0026#39;) } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;bg\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 背景图片默认是重复的（repeat）。\n3 background-repeat 它具有以下值。\n1）默认值repeat\nrepeat会裁剪重复图片超出的部分。\n1 2 3 4 5 .bg{ width: 120px; height: 96px; background-repeat:repeat; } 2）space\nspace是无裁剪的重复。\n其重复原理：\n如果图片不能刚好放下，剩余长或宽将均匀分布在图片之间。 第一张图片一定从左上方的顶点位置开始排列。 如果图片大小超出容器大小，那么将被裁剪。 1 2 3 4 5 .bg{ width: 120px; height: 96px; background-repeat:space; } 1 2 3 4 5 .bg{ width: 160px; height: 96px; background-repeat:space; } 3）round\nround是自适应重复，相比较于space，它会根据元素与图片的大小关系拉伸或缩小图片。\n比如说，一个图片长为$x$，元素长为$X$，$nx \\leq X \\leq mx$，如果$X$更靠近$nx$，那么图片将被放大，如果$X$更靠近$mx$，那么图片将被缩小。\n4）no-repeat\nno-repeat设置图片不允许重复。\n4 background-position background-position用于设定图片的位置，其值类型如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 .bg{ /*关键字*/ background-position:top; background-position:bottom; background-position:center; background-position:left; background-position:right; /*百分比值*/ background-position:50% 50%; /*长度值*/ background-position:10cm 10cm; /*边界偏移值*/ background-position:top 10em left 10px; /*全局值*/ background-position:inherit; /*继承父元素*/ background-position:initial; /*设置为初始值，默认*/ background-position:revert; /*重置为样式表中的值*/ background-position:unset; /*重置为初始值，如果父元素背景位置有定义，继承父元素的值*/ } 5 background-size 用于控制背景图片的尺寸和适应方式。\n初始值：auto auto。\n以下是一些常见的 background-size 值和解释：\n示例使用背景图片（390x693 ）：\n1）auto\n默认值，背景图片大小保持原始尺寸，不进行缩放。\n2）长度值\n使用指定的长度单位（如像素）设置背景图片的宽度和高度。\n例如，background-size: 200px 100px; 将背景图片的宽度设置为 200 像素，高度设置为 100 像素。\n如果只设置一个值，那么该值将作为宽度，高度设为auto。\n3）百分比\n使用指定的百分比值设置背景图片的宽度和高度。\n百分比是相对于包含元素的宽度和高度计算的。\n例如，background-size: 50% 75%; 将背景图片的宽度设置为元素宽度的 50%，高度设置为元素高度的 75%。\n4）cover\n背景图片会完全覆盖整个元素，可能会裁剪部分图片。\n背景图片会被**等比例缩放，**以适应元素的较小维度，然后将其余部分裁剪掉，以确保整个元素都被覆盖。\n较小维度是看 元素长/图片长 以及 元素宽/图片宽 的比值大小。\n1 2 3 width: 390px; height: 500px; background-size:cover 5）contain\n确保整个背景图片完全包含在元素内，不会裁剪图片。\n背景图片会被等比例缩放，以适应元素的较大维度，以确保整个图片都可见，不会被裁剪。\n1 2 3 width: 390px; height: 500px; background-size:contain 6 background-origin 指定背景图片的原点位置在哪个区域的左上角。\n该属性有以下值：\n1）padding-box：默认值。\n1 2 3 4 5 6 7 8 .bg { width: 48px; height: 48px; background-image: url(\u0026#39;./花花.png\u0026#39;); background-origin: padding-box; padding: 5px; border: 5px solid #b95353; } 2）border-box。\n3）content-box。\n7 background-clip background-clip 设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。\n8 background-attachment background-attachment决定图片的滚动行为。\n其值包括：\nscroll（默认值）：背景图片随页面滚动而滚动。\nfixed：背景图片不会随页面滚动而滚动，而是相对于视口的原点（左上角）固定。\n我们观察到这两个元素的背景图片是重叠在一起了。\nlocal：不随页面滚动，但随元素内部滚动而滚动。\n","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/cssbackground/","title":"【CSS】background"},{"content":"JavaScript 字符串简介 JavaScript中的字符串是由16位码元code unit组成。\n通常来说，一个字符=16位码元，该类字符也叫做单码元字符。\n还有一种字符组成策略是代理对，它由两对16位码元组成，即一个字符对应两个16位码元，用于增补字符。\nJavaScript使用两种Unicode编码混合的策略：USC-2和UTF-16。\n深入了解字符编码\nThe Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)\nJavaScript’s Internal Character Encoding:UCS-2 or UTF-16?\n字符串原始值可以调用所有String对象的方法；有3个继承的方法：valueOf()、toLocaleString()、toString()，它们都返回字符串对象的原始字符串值；有1个length属性，其值为字符串所包含的字符数量。\n下面介绍JavaScript字符串的相关方法。\n获取指定位置上的字符、编码、码点 charAt、charCodeAt、codePointAt\ncharAt获取指定位置字符。\ncharCodeAt获取指定位置字符的编码（16进制变成10进制）。\n1 2 3 4 5 6 const str=\u0026#34;Hello,世界!\u0026#34;; console.log(str.charAt(0)); //H console.log(str.charAt(7)); //界 console.log(str.charCodeAt(0)); //72 console.log(str.charCodeAt(7)); //30028 console.log(parseInt(30028).toString(16)); //754c charCodeAt只适合单码元字符，而代理对字符需要使用codePointAt。\n为了正确解析既包含单码元字符又包含代理对字符的字符串，使用codePointAt接收16位码元的索引并返回该索引位置上的码点（Unicode中一个字符的完整标识）。\n1 2 3 const str = \u0026#34;ab😂ba\u0026#34;; console.log(str.charCodeAt(2)); // 55357 console.log(str.codePointAt(2)); // 128514 fromCharCode、fromCodePoint fromCharCode用于根据给定的UTF-16码元创建字符，可以接受多个数值，生成一个字符串。fromCodePoint用给定码点创建字符，同样可接受多个值生成一个字符串。\n1 2 3 4 5 6 7 // 使用 fromCharCode() 创建字符 const char1 = String.fromCharCode(65); // 65 是字符 \u0026#39;A\u0026#39; 的UTF-16码元 console.log(char1); // 输出：A // 使用 fromCodePoint() 创建字符 const char2 = String.fromCodePoint(128514); // 128514 是笑脸符号的码点 console.log(char2); // 输出：😂 两个一样的字符一定相等吗?\n如果这两个字符看着一样，但是对应的字符编码不一样，那么便不相等，例如:\n1 2 3 4 5 6 7 8 9 const char1 = \u0026#39;A\u0026#39;; // 拉丁字母大写A const char2 = \u0026#39;Α\u0026#39;; // 希腊字母大写Alpha // 比较两个字符是否相等 console.log(char1 === char2); // 输出：false，尽管外观相似，但字符编码不同 // 获取字符编码 console.log(char1.charCodeAt(0)); // 输出：65，字符A的Unicode编码 console.log(char2.charCodeAt(0)); // 输出：913，字符Α的Unicode编码 concat concat用于拼接字符串，可以一次性拼接多个字符串，当然我们更常使用 + 号来拼接字符串。\n1 2 3 let str=\u0026#34;Hello \u0026#34; console.log(str.concat(\u0026#34;World\u0026#34;,\u0026#34;!\u0026#34;)) //\u0026#34;Hello World!\u0026#34; console.log(str) //\u0026#34;Hello\u0026#34; 截取子字符串 这三个方法有一定相似，但也有重大不同，且看下文。\n它们都用于提取子字符串，都接受1或2个参数，且第一个参数都是起始位置的索引，如果省略第二个参数，表示截取到字符串末尾。\n不同的地方是，slice和substring第二个参数是结束位置的索引（截取部分不包括该结束位置），而substr第二个参数是从起始位置截取字符串的字符个数。\n值得注意的是，substring它会将较小的数字当成起始位置，可能会出现第一参数大于第二参数的情况。其他两个方法如果第一个参数小于第二个参数，就会返回空字符串。\n对于负数参数，slice会将它们都加上字符串长度（即从右往左数），直到为正数；substr会将第一个负参加上字符串长度，将第二个负参变为0；substring将所有负参转为0。总而言之，只有slice的负参数才有作用，substr和substring包含负参数就一定会返回空字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 let str = \u0026#34;Hello world!\u0026#34; console.log(str.slice(0)) //Hello world! console.log(str.slice(0, 5)) //Hello console.log(str.substring(0)) //Hello world! console.log(str.substring(0, 5)) //Hello console.log(str.substr(0)) //Hello world! console.log(str.substr(0, 5)) //Hello console.log(str.slice(-5)) //orld! console.log(str.substring(-5)) //Hello world! console.log(str.substr(-5)) //orld! console.log(str.slice(0, -5)) //Hello w console.log(str.substring(0, -5)) //空字符串 console.log(str.substr(0, -5)) //空字符串 console.log(str.slice(-5, -2)) //orl console.log(str.substring(-5, -2)) //空字符串 console.log(str.substr(-5, -2)) //空字符串 console.log(str.slice(-2, -5)) //空字符串 console.log(str.substring(-2, -5)) //空字符串 console.log(str.substr(-2, -5)) //空字符串 console.log(str.slice(5, 0)) //空字符串 console.log(str.substring(5, 0)) //Hello console.log(str.substr(5, 0)) //空字符串 获取字符的位置 前文已经介绍了根据位置获取字符串的方法，我们也可以根据字符串获取它的位置——indexOf和lastIndexOf，它们区别在于indexOf是从前往后找，而lastIndexOf是从后往前找。如果没有找到，则返回-1。这两个方法可以接受第二参数，表示开始搜索位置。\nstartsWith、endsWith、includes startsWith、endsWith、includes都是判断是否包含某字符串的方法，返回布尔值。\nincludes检查整个字符串。\nstartsWith和endsWith分别是匹配开头和结尾是否有传入字符串。\nstartsWith和includes都接受第二个参数，表示起始搜索位置。\n去除左边或右边空格 trim、trimLeft、trimRight\ntrim方法删除字符串前后所有空格。\ntrimLeft、trimRight分别删除字符串左边空格和字符串右边空格。不过这两个方法好像在某个版本 deprecated 啦。\n1 2 3 4 let s = \u0026#34; abc \u0026#34;; console.log(\u0026#34;s.trim()=\u0026#34; + s.trim() + \u0026#34;|\u0026#34;); console.log(\u0026#34;s.trimLeft()=\u0026#34;+s.trimLeft()+\u0026#34;|\u0026#34;); console.log(\u0026#34;s.trimRight()=\u0026#34; + \u0026#34;|\u0026#34; + s.trimRight()); 重复字符串 repeat方法接受一个整数作为参数，表示字符串复制的次数，然后返回它们拼接起来的字符串。\n1 2 let s = \u0026#34;a\u0026#34;; console.log(s.repeat(3)); // \u0026#34;aaa\u0026#34; 不改变原字符串。\n填充字符串 padStart和padEnd分别在字符串前面和字符串后面填充指定长度的指定字符串。\n第一参数是填充后字符串要达到的长度，第二参数是要填充的字符串。\n1 2 3 let str = \u0026#34;Hello\u0026#34; console.log(str.padStart(10, \u0026#34;World\u0026#34;)) //WorldHello console.log(str.padEnd(10, \u0026#34;World\u0026#34;)) //HelloWorld 大小写转换 toLowerCase用于将字符串中的所有字符转换为小写，它不受地域设置的影响，只是简单地将字符转换为小写形式。toLocaleLowerCase()不同之处在于，它会受到地域设置的影响，可能会根据当前区域设置将某些特定字符转换为小写形式。\ntoUpperCase、toLocaleUpperCase同上。\n模式匹配相关方法 第一个是match，它本质上和RegExp的exec方法相同，返回匹配结果的数组形式。如果使用全局模式g，它会返回所有匹配结果的数组，否则返回一个数组，其中第一个元素是匹配到的字符串，后续元素是正则表达式中的捕获组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 let str = \u0026#34;To be what we are, and to become what we are capable of becoming, is the only end of life.\u0026#34; // 使用match匹配所有包含a的单词 let reg1 = /\\b[a-zA-Z]*a[a-zA-Z]*\\b/g console.log(str.match(reg1)) // [ \u0026#39;what\u0026#39;, \u0026#39;are\u0026#39;, \u0026#39;and\u0026#39;, \u0026#39;what\u0026#39;, \u0026#39;are\u0026#39;, \u0026#39;capable\u0026#39; ] // 使用match匹配包含a的单词，不使用全局匹配 let reg2 = /\\b[a-zA-Z]*a[a-zA-Z]*\\b/ console.log(str.match(reg2)) // [ // \u0026#39;what\u0026#39;, // index: 6, // input: \u0026#39;To be what we are, and to become what we are capable of becoming, is the only end of life.\u0026#39;, // groups: undefined // ] 第二个是search，返回匹配到的索引位置，没有匹配项就返回-1。\n1 2 3 4 5 let str = \u0026#34;To be what we are, and to become what we are capable of becoming, is the only end of life.\u0026#34; // 使用search匹配we let reg = /we/g console.log(str.search(reg)) // 11 第三个是replace，它使用新的字符串或函数替换正则表达式匹配的内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const originalString = \u0026#34;Hello, world! Hello, universe!\u0026#34;; // 替换字符串中的单个匹配项 const replacedString1 = originalString.replace(\u0026#34;world\u0026#34;, \u0026#34;friends\u0026#34;); console.log(replacedString1); // 输出：Hello, friends! Hello, universe! // 使用正则表达式进行替换（只替换第一个匹配项） const replacedString2 = originalString.replace(/Hello/, \u0026#34;Hi\u0026#34;); console.log(replacedString2); // 输出：Hi, world! Hello, universe! // 使用正则表达式进行替换（替换所有匹配项） const replacedString3 = originalString.replace(/Hello/g, \u0026#34;Hi\u0026#34;); console.log(replacedString3); // 输出：Hi, world! Hi, universe! // 使用$1、$2、$3、$4等来替换匹配项 const replacedString4 = originalString.replace(/(Hello), (world)! (Hello), (universe)!/g, \u0026#34;$3, $4! $1, $2!\u0026#34;); console.log(replacedString4); // 输出：Hello, universe! Hello, world! // 使用函数来替换匹配项 const replacedString5 = originalString.replace(/(Hello), (world)! (Hello), (universe)!/g, function (matched, p1, p2, p3, p4, offset, original) { console.log(matched) // 匹配到的字符串 console.log(offset) // 匹配到的字符串在原字符串中的偏移量 console.log(original) // 原字符串 return p3 + \u0026#34;, \u0026#34; + p4 + \u0026#34;! \u0026#34; + p1 + \u0026#34;, \u0026#34; + p2 + \u0026#34;!\u0026#34;; } ); console.log(replacedString5); // 输出：Hello, universe! Hello, world! 最后一个是split，它根据传入的分隔符将字符串划分为一个数组，分隔符可以是字符串或RegExp对象。\n1 2 3 4 5 6 7 8 9 const str=\u0026#34;apple,banana,orange\u0026#34; //以逗号作为分隔符 console.log(str.split(\u0026#34;,\u0026#34;)) //[\u0026#34;apple\u0026#34;,\u0026#34;banana\u0026#34;,\u0026#34;orange\u0026#34;] //限定数组大小 console.log(str.split(\u0026#34;,\u0026#34;,2)) //[\u0026#34;apple\u0026#34;,\u0026#34;banana\u0026#34;] //使用正则表达式 const text=\u0026#34;apple orange\\tbanana\u0026#34; const parts=text.split(/\\s+/) //匹配连续空格 console.log(parts) //[\u0026#34;apple\u0026#34;,\u0026#34;orange\u0026#34;,\u0026#34;banana\u0026#34;] 迭代方法 字符串的原型上暴露了@@iterator方法\n1 2 3 4 5 6 const str = \u0026#34;abc\u0026#34; const str2 = str[Symbol.iterator]() console.log(str2.next()) //{ value: \u0026#39;a\u0026#39;, done: false } console.log(str2.next()) //{ value: \u0026#39;b\u0026#39;, done: false } console.log(str2.next()) //{ value: \u0026#39;c\u0026#39;, done: false } console.log(str2.next()) //{ value: undefined, done: true } 通过该迭代器，我们使用for-of遍历字符串，以及使用解构操作符结构字符串。\nlocaleCompare localeCompare比较字符串与字符串参数在字母表的顺序前后，如果字符串位于字符串参数前，则返回负值；如果相等，则返回0；如果字符串位于字符串参数后，则返回正值。\n","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/","title":"【JavaScript】字符串方法"},{"content":"混入（Mixins）是一种在Vue组件中重用代码的方式。它允许你定义一些可复用的选项对象，然后将这些选项合并到不同的组件中。混入可以用于在多个组件之间共享逻辑、方法、生命周期钩子等。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vue mixin demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;my-component\u0026gt;\u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 定义一个混入对象 const myMixin = { data() { return { message: \u0026#39;Hello from mixin!\u0026#39; } }, methods: { greet() { console.log(this.message) } } } Vue.component(\u0026#39;my-component\u0026#39;, { mixins: [myMixin], template: \u0026#39;\u0026lt;div\u0026gt;{{message}}\u0026lt;/div\u0026gt;\u0026#39;, created() { this.greet() } }) var vm = new Vue({ el: \u0026#39;#app\u0026#39;, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 选项合并\n当组件和混入对象的选项同名时，数据对象data中同名选项以组件的优先，进行递归合并；同名钩子函数则会被合并为数组，它们都会执行，且混入对象的钩子函数先执行。\n对于methods、components、directives这些值为对象的选项，同名键的合并例子如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vue mixin demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const mixin = { methods: { greet() { console.log(\u0026#39;Hello from Mixin!\u0026#39;); }, sayHello() { console.log(\u0026#39;Mixin says hello!\u0026#39;); }, } }; var Component = Vue.extend({ methods: { greet() { console.log(\u0026#39;Hello from extend!\u0026#39;); }, sayHello() { console.log(\u0026#39;extend says hello!\u0026#39;); }, sayGoodbye() { console.log(\u0026#39;extend says goodbye!\u0026#39;); } } }); new Component({ mixins: [mixin], methods: { greet() { console.log(\u0026#39;Hello from component!\u0026#39;); }, }, created() { this.greet(); // Output: Hello from component! this.sayHello(); // Output: Mixin says hello! this.sayGoodbye(); // Output: extend says goodbye! } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 由上面得出选项合并优先级：new Component \u0026gt; mixins \u0026gt; Vue.extend。\n全局混入\n全局混入会影响每一个Vue实例。\n使用Vue.mixin({})方法创建全局混入。\n尽量避免使用全局混入，这样会导致逻辑分散、代码难以阅读、维护困难。\n⭐自定义选项合并策略\n下面是一个示例：\n1 2 3 4 5 6 7 const customMergeStrategies=Vue.config.optionMergeStrategies customMergeStrategies.customOption=function(parentVal,childVal){ if(!childVal) return parentVal if(!parentVal) return childVal //合并逻辑，可根据需要修改 return parentVal.concat(childVal) } 关键是了解Vue.config.optionMergeStrategies的作用，它用于帮助我们自定义某个选项的合并策略函数，该函数第一个参数是父组件的该选项值，第二个参数是子组件的该选项值。\n","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/vue-2mixin/","title":"【Vue 2】Mixin"},{"content":"1 前言 学习Vue的过程中，我们常常会注意到依赖追踪这个词，什么是依赖？又该如何追踪呢？\n首先，我们知道Vue的响应式系统是其独特的特性，经典的一句话：视图随着状态变化而变化。而依赖追踪与其工作原理联系紧密。\n从状态生成DOM，再显示到用户界面的过程称为渲染。响应式系统则负责页面的重渲染。所以，大致重渲染过程应该是状态变化-\u0026gt;重渲染。要及时侦测到数据的变化，就要依靠Vue的变化侦测系统，就是我们所说的依赖追踪。\n这篇文章，我们仅讨论Object的变化侦测。关于Array的变化侦测部分我们在另一篇文章再谈。\n变化侦测，侦测的是该变化隶属于哪些DOM元素。\n在Vue 2.0之前，一个依状态会绑定在多个依赖，一个依赖对应一个DOM节点，所以当该状态改变时就通知其所有依赖进行更新。\nVue 2.0引入了虚拟DOM的概念，虚拟DOM使得一个依赖不再是具体的DOM节点，而是一个组件，如此，状态变化时，组件内部将虚拟DOM与真实DOM比对。因此，我们不再需要对每个状态绑定的DOM元素进行追踪，减少了大量依赖，降低了追踪依赖所消耗的内存负担。\n2 具体实现 接下来，就谈谈变化侦测具体的JavaScript实现。\nJasvaScript中，Object.defineProperty和ES6的Proxy都可以侦测数据的变化。Vue 2使用了Object.defineProperty，Vue3则使用了更为强大的Proxy。\n本文仅讨论Vue2。\n2.1 defineReactive函数 一个简单的响应式系统如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // data为属性对象，key为属性名，val为属性初始值 function defineReactive(data,key,val){ //dep：依赖收集数组，用于存储属性的订阅者，也就是观察者 //当属性被访问时，订阅者被添加到dep，以便在属性更新时进行通知 let dep=[]; Object.defineProperty(data,key,{ //表示该属性可被枚举 enumerable:true, //表示该属性可被修改或删除 configurable:true, //getter方法，属性被访问时，执行该函数 get:function(){ //将当前订阅者添加到dep数组 dep.push(window.target) //返回当前值 return val }, //setter函数，属性被修改时，执行该函数 set:function(newVal){ //新值与旧值相等就不更新 if(val===newVal){ return } //否则遍历dep数组，更新所有依赖的值 for(let i=0;i\u0026lt;dep.length;i++){ dep[i](newVal,val) } //更新值 val=newVal } }) } 上述代码定义了一个 defineReactive 函数，它将属性对象 data 中的属性 key 转化为响应式属性。每个响应式属性都与一个名为 dep 的依赖管理器相关联。当属性被访问时，订阅者（观察者）会被添加到 dep 数组中，以便在属性更新时通知它们。\n2.2 Dep类 我们可以将依赖收集的代码封装成一个Dep类，降低代码耦合度：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 export default class Dep{ constructor(){ this.subs=[] } //添加一个订阅者（观察者）到依赖列表 addSub(sub){ this.subs.push(sub) } //从依赖列表中移除一个订阅者 removeSub(sub){ remove(this.subs,sub) } //在属性被访问时，将当前订阅者添加到依赖列表中 depend(){ if(window.target){ this.addSub(window.target) } } //在属性更新时，通知所有订阅者进行更新操作 notify(){ const subs=this.subs.slice(); for(let i=0;i\u0026lt;subs.length;i++){ subs[i].update(); } } } function remove(arr,item){ if(arr.length){ const index=arr.indexOf(item) if(index\u0026gt;-1){ return arr.splice(index,1) } } } 再修改defineReactive：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function defineReactive(data,key,val){ let dep=new Dep() Object.defineProperty(data,key,{ enumerable:true, configurable:true, get:function(){ dep.depend() return val }, set:function(newVal){ if(val===newVal){ return } val=newVal dep.notify() } }) } 2.3 Watcher类 上面代码中，我们收集的是window.target，实际上它既可以是用户模板中的表达式，也可以是一个watch、computed，于是Vue抽象出一个Watcher类来管理这多种情况，我们只需收集Watcher实例即可。\nWatcher是对依赖关系的封装，它的主要作用是建立依赖关系，当数据变化时通知相关的 Watcher 执行更新操作。\n因此，依赖变成了数据属性与Watcher的关系。一个依赖列表里是同一个属性的依赖，包含了依赖于该属性的Watcher。\n使用vm.$watch方法建立Watcher：\n1 2 3 4 5 //keypath //a.b.c是属性路径，位于data属性 vm.$watch(\u0026#39;a.b.c\u0026#39;,function(newVal,oldVal){ //... }) 下面是简化版的Watcher实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 export default class Watcher { // vm：Vue 实例，expOrFn：表达式或函数，callback：回调函数 constructor(vm, expOrFn, callback) { this.vm = vm; // 属性获取函数 this.getter = parsePath(expOrFn); this.callback = callback; this.value = this.get(); } // 获取属性值 get() { // 将当前的 Watcher 实例设置为全局变量 window.target = this; // 通过 getter 获取 Vue 实例的属性值，同时触发依赖收集 let value = this.getter.call(this.vm, this.vm); // 清除全局变量 window.target = undefined; return value; } update() { // 获取旧值 const oldValue = this.value; // 重新获取值 this.value = this.get(); // 调用回调函数，传递新旧值作为参数 this.callback.call(this.vm, this.value, oldValue); } } 我们通过Watcher读取数据时，会触发getter方法将Watcher实例添加到依赖中。当数据发生了变化，会触发setter，从而向依赖管理器Dep中的依赖（Watcher）列表发送更新通知。\n下面是parsePath的简单代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //检查路径字符串是否包含除了字母、数字、下划线、点及美元符号之外的特殊字符 const bailRE=/[^\\w.$]/ export function parsePath(path){ if(bailRE.test(path)){ return } const segments=path.splits(\u0026#39;.\u0026#39;) return function(obj){ for(let i=0;i\u0026lt;segments.length;i++){ if(!obj) return obj=obj[segments[i]] } return obj } } parsePath 函数用于解析属性路径字符串，确保它仅包含字母、数字、下划线、点和美元符号。它返回一个函数，该函数接受一个对象作为参数，可以根据属性路径访问对象的属性。\n2.4 Observer类 前面的代码只能侦测一个属性，且不包括其子属性。为了能够侦测 data 中所有属性及其子属性的变化，需要使用 Observer 类来遍历并将它们都转化为 getter/setter 的形式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 export class Observer { constructor(value) { this.value = value; // 非数组 if (!Array.isArray(value)) { this.walk(value); } } walk(obj) { const keys = Object.keys(obj); for (let i = 0; i \u0026lt; keys.length; i++) { // 对每个属性调用defineReactive defineReactive(obj, keys[i], obj[keys[i]]); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 定义响应式数据 function defineReactive(data, key, val) { // 是对象类型，就使用Observer遍历其属性 if (typeof val === \u0026#34;object\u0026#34;) { new Observer(val); } // 依赖管理器 let dep = new Dep(); Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function () { // 依赖收集，即添加Watcher dep.depend(); return val; }, set: function (newVal) { if (val === newVal) { return; } val = newVal; // 通知依赖更新 dep.notify(); }, }); } 当Vue实例化时，Observer会遍历数据对象的属性。\n依赖追踪的过程基本上就这样，但要注意有一个缺陷：无法追踪新增属性和删除属性，只能追踪属性是否被修改。于是Vue.js提供了vm.$set和vm.$delete来解决该问题。\n3 总结 数据属性（Data Properties）的依赖追踪是 Vue 响应式系统的核心之一，它使得数据与视图能够自动关联，从而实现了视图随着数据变化而变化的特性。在 Vue 中，依赖追踪主要包括以下关键点：\nDep 类：用于管理依赖（观察者），包括添加、移除依赖和通知依赖更新的功能。 Watcher 类：用于建立依赖关系，当数据变化时通知相关的 Watcher 执行更新操作。 defineReactive 函数：将数据属性转化为响应式属性，并管理与之相关的依赖。 Observer 类：遍历对象的属性，将它们都转化为 getter/setter 的形式，以便进行依赖追踪。 整个依赖追踪的过程可以概括为：\n数据属性被观察者遍历，每个属性都被转化为响应式属性。 每个响应式属性与一个依赖管理器关联，用于管理依赖的订阅者。 当数据属性被访问时，订阅者（观察者）被添加到依赖列表中，以便在属性更新时通知它们。 当数据属性发生变化时，依赖管理器会通知所有订阅者执行更新操作，确保视图与数据保持同步。 ","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/vue-2object%E7%9A%84%E4%BE%9D%E8%B5%96%E8%BF%BD%E8%B8%AA%E5%8E%9F%E7%90%86/","title":"【Vue 2】Object的依赖追踪原理"},{"content":"可以先阅读组件基础-简单了解通过插槽分发内容。\n一、插槽定义 插槽将子组件标签间的内容分发到子组件模板的\u0026lt;slot\u0026gt;标签位置。\n如果没有\u0026lt;slot\u0026gt;标签，那么该内容将被丢弃。\n二、编译作用域 内容在哪个作用域编译，就可以访问哪个作用域的数据。\n1.父级模板的作用域\n在父组件的模板中定义的变量，可以在整个父组件的模板中访问，包括子组件中的插槽内容。\n例如，我们在父组件中定义一个变量url，在子组件插槽内容中访问：\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;navigation-link url=\u0026#34;./index\u0026#34;\u0026gt; This URL is {{url}} \u0026lt;/navigation-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 2.子级模板的作用域\n在子组件中定义的数据和变量，只能在子组件中访问，而不能在父组件中访问。\n三、后备内容 插槽的后备内容即没有提供内容时的默认内容。\n定义方式很简单：\n1 \u0026lt;slot\u0026gt;Slot的默认内容\u0026lt;/slot\u0026gt; 四、具名插槽 顾名思义：具有名字的插槽。\n你可以为插槽指定名称name，以便将内容分发到特定的插槽中。\n接着，通过在template元素上使用v-slot:插槽名参数指令使用具名插槽：\n完整示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vue 2 具名插槽 Demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;my-layout\u0026gt; \u0026lt;p\u0026gt;主要内容的一个段落。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;另一个主要段落。\u0026lt;/p\u0026gt; \u0026lt;template v-slot:header\u0026gt; \u0026lt;h1\u0026gt;这里可能是一个页面标题\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:footer\u0026gt; \u0026lt;p\u0026gt;这里是一些联系信息\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/my-layout\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;my-layout\u0026#39;,{ template:` \u0026lt;div\u0026gt; \u0026lt;header\u0026gt; \u0026lt;slot name=\u0026#34;header\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; \u0026lt;!--默认插槽，隐含name为`default`--\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; ` }) var vm = new Vue({ el: \u0026#39;#app\u0026#39;, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 虽然我们故意将默认插槽的内容放在了名为header的代码前面，但是结果依然按照插槽原本的顺序排列。\n一个组件中默认插槽只能有一个。\n动态插槽名\n我们可以使用动态参数绑定插槽名。\n1 \u0026lt;template v-slot:[dynamicSlotName]\u0026gt;\u0026lt;/template\u0026gt; 具名插槽的缩写\nv-slot指令也有缩写，即使用#替代v-slot:，这样做我们就必须明确给出其插槽名称。\n五、作用域插槽 作用域插槽这个概念是指让插槽内容能够访问子组件中才有的数据。\n我们只需给\u0026lt;slot\u0026gt;绑定prop，然后使用v-slot的值访问该prop。v-slot的值实际上是所有绑定的prop的集合。\n上例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vue 2 作用域插槽 Demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;my-component\u0026gt; \u0026lt;template v-slot=\u0026#34;slotProps\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{slotProps.text}}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;my-component\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;slot text=\u0026#34;hello\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; ` }) var vm = new Vue({ el: \u0026#39;#app\u0026#39;, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注意，上面例子中我们v-slot指令没有带参数，实际上它默认带了个default参数，如果存在别的具名插槽，那么我就必须为v-slot指令带上参数。\n通过作用域插槽的机制，我们可以实现父组件控制插槽内容来控制子组件渲染不同的结果。\n额外的不相关话题：使用v-bind指令时，什么时候加:？\n私以为：这取决于v-bind绑定的属性的值，其值为静态字符串，不加:，其值若为变量或对象字面量，则加:。\n解构插槽prop\n事实上，插槽内容会被封装在一个函数内，v-slot的值就是其参数。\n作为函数参数，我们可以使用JavaScript的解构语法，这会使得代码更简洁。\n1.普通解构\n1 2 3 \u0026lt;template v-slot=\u0026#34;{text}\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{text}}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 2.重命名prop\n1 2 3 \u0026lt;template v-slot=\u0026#34;{text:msg}\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{msg}}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 3.指定后备内容\n1 2 3 \u0026lt;template v-slot=\u0026#34;{text={msg:\u0026#39;Hello\u0026#39;}}\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{text.msg}}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; ","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/vue-2slots/","title":"【Vue 2】Slots"},{"content":"Vue.js是什么 Vue（读音 /vjuː/，类似于view）是一套用于构建用户界面的前端渐进式JavaScript框架，被设计为自底向上逐层应用。\n“渐进式”意味着可以按需引入Vue，而不必一次性全部采用。\n“自底向上逐层应用”意味着从底层开始构建，并逐渐添加层次化的功能。\nVue的核心库只关注视图层，易于上手和与第三方库或既有项目结合。\n另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n“现代化的工具链”通常包括构建工具、打包工具、模块化系统等，如Webpack、Babel，这些工具帮助开发者更加高效地编写、组织和部署代码。Vue可以与这些工具无缝结合使用。\n“类库”：诸如状态管理库（Vuex/Pinia）、路由库（Vue Router）、UI组件库（Element UI、Ant Design）等，Vue与这些库集成，可以构建出强大的单页应用。\n“单页应用”，Single Page Application，简写为SPA，SPA是一种现代化地Web应用程序，旨在在单个页面上提供与用户交互所需的全部功能，而无需刷新页面。\n安装 1.直接用\u0026lt;script\u0026gt;引入Vue\n我们可以先下载开发版本或生产版本(压缩版，删除了警告)的Vue，然后使用\u0026lt;script\u0026gt;标签引入，这样会注册一个全局Vue变量。\n2.使用CDN引入Vue\nCDN，全称Content Delivery Network，即内容分发网络。它可以让你在不下载和存储Vue.js文件的情况下使用Vue框架。\n具体像下面这样使用：\n1 2 3 4 5 6 7 8 # 制作原型或学习 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; # 用于生成环境 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.14\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; # 使用原生ES Modules \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import Vue from \u0026#39;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.esm.browser.js\u0026#39; \u0026lt;/script\u0026gt; 原生ES Modules是JavaScript中的一种模块化系统，在ES6中引入。ES Modules允许开发者将代码划分成独立模块，以便更好的组织代码、管理和复用代码。\nVue 也可以在 unpkg 和 cdnjs 上获取 (cdnjs 的版本更新可能略滞后)。\n3.使用NPM引入Vue\n构建大型Vue项目时，建议使用NPM安装Vue。因为NPM能很好地和诸如Webpack和Browserify模块打包器配合使用，Vue也提供配套工具（如Vue-cli）来开发单文件组件。\n1 2 # 最新稳定版 $ npm install vue 4.命令行工具（CLI）\n详情可查阅 Vue CLI 的文档。\n5.Bower\nBower只提供UMD版本。\n1 2 # 最新稳定版本 $ bower install vue 6.AMD模块加载器\nAMD是浏览器端模块化开发的规范，需要用到对应的库函数RequireJS。\n所有 UMD 版本都可以直接用作 AMD 模块。\nVue兼容性 Vue不支持IE8及以下版本，因为Vue使用了IE8无法模拟的ECMAScript 5特性，它支持所有兼容ECMAScript 5的浏览器。\n语义化版本控制 Vue在其所有项目中公布的功能和行为都遵循语义化版本控制，对于未公布的或内部暴露的行为，其变更会描述在发布说明中。\n“语义化版本控制”意味着每次发布新版本，版本号都会遵循一定规则进行更新，以表明版本变化的含义。语义化版本号的格式通常为MAJOR.MINOR.PATCH。\nMAJOR：当进行不向后兼容（不兼容旧版本）的重大变更时添加。 MINOR：当添加新功能但保持向后兼容时增加。 PATCH：当进行向后兼容的Bug修复时添加。 Vue Devtools 建议在浏览器安装上Vue Devtools这个插件，它提供方便的功能和友好的界面来调试和优化Vue应用。具体地，Vue Devtools允许开发者在浏览器中查看Vue应用的组件层级、监视组件的状态变化、查看事件的出发情况、查看和编辑组件的数据等。\n对不同构建版本的解释 在 NPM 包的 dist/ 目录你将会找到很多不同的 Vue.js 构建版本。\nUMD CommonJS ES Module (基于构建工具使用) ES Module (直接用于浏览器) 完整版 vue.js vue.common.js vue.esm.js vue.esm.browser.js 只包含运行时版 vue.runtime.js vue.runtime.common.js vue.runtime.esm.js - 完整版 (生产环境) vue.min.js - - vue.esm.browser.min.js 只包含运行时版 (生产环境) vue.runtime.min.js - - - 术语解释：\n完整版：同时包含编译器和运行时的版本。 编译器：用来将模板字符串编译成JavaScript渲染函数的代码。 运行时：用来创建Vue实例、渲染并处理虚拟DOM等的代码。基本上就是除去编译器的一切。在生产环境中，通常使用运行时版本，因为模板编译通常在构建阶段完成。 UMD：全称Universal Module Define，UMD 版本可以通过 \u0026lt;script\u0026gt; 标签==直接用在浏览器==中。jsDelivr CDN 的 https://cdn.jsdelivr.net/npm/vue@2.7.14 默认文件就是运行时 + 编译器的 UMD 版本 (vue.js)。 CommonJS：CommonJS 版本用来配合==老的打包工具==比如 Browserify 或 webpack 1。这些打包工具的默认文件 (pkg.main) 是只包含运行时的 CommonJS 版本 (vue.runtime.common.js)。 ES Module：从 2.6 开始 Vue 会提供两个 ES Modules (ESM) 构建文件： 为打包工具提供的 ESM：为诸如 webpack 2 或 Rollup 提供的现代打包工具。ESM 格式被设计为可以被静态分析，所以打包工具可以利用这一点来进行“tree-shaking”并将用不到的代码排除出最终的包。为这些打包工具提供的默认文件 (pkg.module) 是只有运行时的 ES Module 构建 (vue.runtime.esm.js)。 为浏览器提供的 ESM (2.6+)：用于==在现代浏览器中通过 \u0026lt;script type=\u0026quot;module\u0026quot;\u0026gt; 直接导入==。 与自定义元素的关系 Vue支持与自定义元素进行集成，可以通过以下方法将Vue组件构建成原生的自定义元素，从而让Vue组件能够在支持Cutome Element的环境中使用：\n1.安装vue-custome-element库：\n1 npm install vue-custome-element 2.在Vue组件中注册自定义元素：\n1 2 3 4 5 6 7 8 9 import Vue from \u0026#39;vue\u0026#39; import vueCustomeElement from \u0026#39;vue-custome-element\u0026#39; import MyComponent from \u0026#39;./MyComponent.vue\u0026#39; //使用vue-custome-element插件 Vue.use(vueCustomeElement) //注册自定义元素 Vue.customElement(\u0026#39;my-custome-element\u0026#39;,MyComponent); 其他demo。\n在Vue3中有原生API支持自定义元素。\nVue CLI也支持将Vue组件构建成为原生的自定义元素。\nVue CLI是Vue官方提供的一个命令行工具，用于快速搭建Vue项目，在Vue CLI中，可以使用vue-cli-service build --target wc --name my-element src/App.vue命令将App.vue组件构建成自定义元素，并指定名称为my-elemnt。\n","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/vue-2%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/","title":"【Vue 2】介绍与安装"},{"content":"先阅读 【Vue 2 组件基础】中的初步了解动态组件。\n动态组件 我们知道动态组件使用is属性和component标签结合来切换不同组件。\n下面给出一个示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- tab 标签页 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;tab = \u0026#39;home\u0026#39;\u0026#34;\u0026gt;首页\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;tab = \u0026#39;posts\u0026#39;\u0026#34;\u0026gt;文章\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 父组件count: {{count}} \u0026lt;!-- 动态组件 --\u0026gt; \u0026lt;component :is=\u0026#34;tab\u0026#34; @increment=\u0026#34;count=$event\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 注册组件 Vue.component(\u0026#39;home\u0026#39;, { data: function () { return { count: 0 } }, template: ` \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;首页内容\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;子组件count: {{count}}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;count++;$emit(\u0026#39;increment\u0026#39;, count)\u0026#34;\u0026gt;点击了{{count}}次\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; `, }); Vue.component(\u0026#39;posts\u0026#39;, { template: \u0026#39;\u0026lt;div\u0026gt;文章内容\u0026lt;/div\u0026gt;\u0026#39; }); var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { tab: \u0026#39;home\u0026#39;, count: 0 }, }); \u0026lt;/script\u0026gt; 看代码可以知道父组件的count会在子组件count更新后变为子组件的count值。但我们切换组件后再切换回来，会发现父组件count没变，子组件count变为初始值。这是因为，每次切换组件都会创建当前组件的新实例。\n那怎么保存先前组件的状态呢？\nVue提供了keep-alive组件。我们使用该元素将要缓存的组件包裹起来。让我们看看效果：\n1 2 3 \u0026lt;keep-alive\u0026gt; \u0026lt;component :is=\u0026#34;tab\u0026#34; @increment=\u0026#34;count=$event\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/keep-alive\u0026gt; 成功解决问题！\n\u0026lt;keep-alive\u0026gt;的注意事项：\n\u0026lt;keep-alive\u0026gt;本身不会渲染为DOM元素。 当\u0026lt;keep-alive\u0026gt;内组件切换时，会执行activated和deactivated两个生命周期钩子函数。 \u0026lt;keep-alive\u0026gt;不会在函数式组件中正常工作，因为它们没有缓存实例。 被切换的组件需要设置name选项。 异步组件 在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。\nVue简化了这个过程的实现。\nVue允许我们以工厂函数的形式定义组件。\n1 2 3 4 5 6 7 Vue.component(\u0026#39;async-component\u0026#39;,function(resolve,reject){ setTimeout(function(){ resolve({ template:\u0026#39;\u0026lt;div\u0026gt;\u0026lt;h2\u0026gt;Async Component Content\u0026lt;/h2\u0026gt;\u0026lt;/div\u0026gt;\u0026#39; }); },1000); }); 工厂函数里可以异步地resolve来自服务器的组件定义对象。如果组件load failed，也可以调用reject(reason)。\n这样定义的组件只有当它需要被render时才会被加载，而且会缓存渲染结果用于以后的重新渲染。\n使用Vue.component方法结合webpack的code-splitting来定义一个factory函数：\n1 2 3 4 5 6 Vue.component(\u0026#39;async-webpack-example\u0026#39;, function (resolve) { // 这个特殊的 `require` 语法将会告诉 webpack // 自动将你的构建代码切割成多个包，这些包 // 会通过 Ajax 请求加载 require([\u0026#39;./my-async-component\u0026#39;], resolve)； })； 我们也可以在factory函数中返回一个Promise，\n1 2 3 4 Vue.component( `async-webpack-example`, ()=\u0026gt;import(\u0026#39;./my-async-component\u0026#39;) ); ()=\u0026gt;import('./my-async-component')返回一个Promise，那么就可以根据Promise的状态来自动处理异步加载和渲染的过程。\nimport() return value\nReturns a promise which fulfills to a module namespace object: an object containing all exports from moduleName.\nThe evaluation of import() never synchronously throws an error. moduleName is coerced to a string, and if coercion throws, the promise is rejected with the thrown error.\n局部注册异步组件：\n1 2 3 4 5 new Vue({ components:{ \u0026#39;my-component\u0026#39;:()=\u0026gt;import(\u0026#39;./my-async-component\u0026#39;) } }) 处理加载状态 异步组件工厂函数可以返回一个对象，该对象包含有关异步组件加载、加载中、加载失败等情况的配置信息，这种方式允许你更加精细地控制异步组件地加载和渲染过程。下面是这种格式的异步组件配置对象的详细解释：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const AsyncComponent=()=\u0026gt;({ //需要加载的组件 component:import(\u0026#39;./MyComponent.vue\u0026#39;), //异步加载时使用的组件 loading:LoadingComponent, //加载失败时使用的组件 error:ErrorComponent, //展示加载时组件的延迟时间，默认值是200（毫秒） delay:200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity`，即没有超时限制 timeout: 3000 }); Vue.component(\u0026#39;async-component\u0026#39;, AsyncComponent); 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;async-component\u0026gt;\u0026lt;/async-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 参考资料 keep-alive Dynamic \u0026amp; Async Components import() ","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/vue-2%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6/","title":"【Vue 2】动态组件和异步组件"},{"content":"访问元素和组件 通过Vue 2 组件基础一文的学习，我们知道组件之间可以通过传递props或事件来进行通信。\n但在一些情况下，我们使用下面的方法将更有用。\n1.访问根实例\n根实例可通过this.$root获取。\n我们在所有子组件中都可以像上面那样访问根实例，它就像一个vuex中的全局store。\n这样我们可以在根实例上定义方法和属性，这些方法和属性可以在所有组件中访问。\n根实例也可以用作事件总线，你可以触发根实例上的自定义事件，在其他组件上监听这些事件以进行通信。一个示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vue 事件总线\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;sendMessage\u0026#34;\u0026gt;Send Message By Root\u0026lt;/button\u0026gt; \u0026lt;child-component\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 注册组件 Vue.component(\u0026#39;child-component\u0026#39;, { data: function () { return { childMessage:\u0026#39;childMsg\u0026#39; } }, template: ` \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Message in ChildComponent：{{childMessage}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `, created(){ //通过 this.$root 监听`message-sent`事件 this.$root.$on(\u0026#39;message-sent\u0026#39;,message=\u0026gt;{ this.childMessage=message }) } }); var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data:{ message:\u0026#39;rootMsg\u0026#39; }, methods:{ sendMessage(){ //在根实例上触发自定义事件\u0026#39;message-sent\u0026#39; this.$emit(\u0026#39;message-sent\u0026#39;,this.message) } } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;script\u0026gt; 2.访问父组件实例、访问子组件实例或子元素\n之前我们可以通过传递prop来达到 子组件访问父组件实例 或者称为 父组件向子组件传值 的目的。\n现在我们可以使用$parent property来访问父级组件实例。\n之前我们也通过触发自定义事件传递抛出值的方式来访问子组件实例。\n同样的，我们可以通过ref attribute为子组件或子元素添加一个 ID 引用。\n1 \u0026lt;child-component ref=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; 于是可以使用this.$refs.child来访问子组件实例。\n通过ref引用子组件示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vue ref 示例\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;toggleColor\u0026#34;\u0026gt;Toggle Color\u0026lt;/button\u0026gt; \u0026lt;p :style=\u0026#34;{ color: textColor }\u0026#34;\u0026gt;This text color can be toggled.\u0026lt;/p\u0026gt; \u0026lt;child-component ref=\u0026#34;childRef\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 子组件 Vue.component(\u0026#39;child-component\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;This is a child component.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `, methods: { sayHello() { console.log(\u0026#39;Hello from child component!\u0026#39;); } } }); var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { textColor: \u0026#39;black\u0026#39;, isChildVisible: true }, methods: { toggleColor() { this.textColor = this.textColor === \u0026#39;black\u0026#39; ? \u0026#39;red\u0026#39; : \u0026#39;black\u0026#39;; // 通过 ref 访问子组件实例中的方法 this.$refs.childRef.sayHello(); } } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 3.依赖注入\n不管是this.$parent、this.$refs，都可能会陷入深层嵌套的风险，我们可能会通过this.$parent.$parent.$parent来访问上层某个组件实例。这无疑是不合理的。\n针对较深层级的组件访问，Vue设计了依赖注入的模式。它允许我们将一个依赖注入到某个组件里，以便组件可以访问这个依赖而不需要显示传递它。这对于共享全局配置或服务非常有用，例如国际化（i18n）配置、数据请求服务等。\n具体的，我们通过在父组件provide选项提供依赖，然后在子组件的inject选项注入依赖。\n示例：\n1 2 3 4 5 6 7 8 9 10 //在父组件中 provide:{ userSevice:new UserService() } //在子组件中 inject:[\u0026#39;userService\u0026#39;], created(){ this.userService.doSomething() } 为什么我们不使用$root实现这种方案呢？我认为，依赖注入适合小范围的配置共享，而全局共享则适用于$root。\n程序化的事件监听器 $emit触发的事件可以被v-on监听，但这不是我们这章的内容。\n本文主要介绍 Vue 2 中程序化的事件监听器，我们可以使用它来动态地添加和删除事件监听器。\nVue实例上有一系列方法来处理事件，包括$on、$once和$off。它们都包含两个参数：eventName和eventHandler。$on侦听一个事件；$once只侦听一个事件一次；$off停止侦听一个事件。\n$emit、$on和$off与浏览器的EventTarget API 中的dispatchEvent、addEventListener和removeEventListener并不等同。\n$emit用于触发自定义事件，dispatchEvent用于触发各种DOM事件。addEventListener和removeEventListener同理。\n组件的循环引用 1.递归组件\n我们可以在组件模板内部调用自身，这称为递归组件。递归组件要注意设置递归终止条件，例如v-if的值为false。\n假设我们有一个表示文件夹结构的数据对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vue 2 递归组件 Demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;recursive-folder :folder=\u0026#34;folder\u0026#34;\u0026gt;\u0026lt;/recursive-folder\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;recursive-folder\u0026#39;, { props: [\u0026#39;folder\u0026#39;], template: ` \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;{{ folder.name }}\u0026lt;/span\u0026gt; \u0026lt;div v-if=\u0026#34;folder.children.length \u0026gt; 0\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;childFolder in folder.children\u0026#34; :key=\u0026#34;childFolder.name\u0026#34;\u0026gt; \u0026lt;recursive-folder :folder=\u0026#34;childFolder\u0026#34;\u0026gt;\u0026lt;/recursive-folder\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ` }); var vm = new Vue({ el: \u0026#39;#app\u0026#39;, name: \u0026#39;recursive-folder\u0026#39;, data: { folder: { name: \u0026#39;Folder A\u0026#39;, children: [ { name: \u0026#39;Subfolder A.1\u0026#39;, children: [ { name: \u0026#39;File A.1.1\u0026#39;, children: [] }, // 可能有更多子项 ] }, { name: \u0026#39;File A.2\u0026#39;, children: [] }, // 可能有更多子项 ] } }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2.循环组件\n循环组件是不同组件互相使用，递归组件是自身使用自身。\n使用Vue.component全局注册组件时，Vue帮助我们自动解决组件之间的依赖关系，因此你可以随意使用它们。\n但是，当我们使用模块系统（如Webpack）时，便可能出现循环依赖的情况。\n为了解决该问题，你可以在组件的beforeCreate生命周期钩子函数中动态注册依赖组件，或者使用异步组件加载来确保组件能够正确解析和注册：\n1）在组件的beforeCreate生命周期钩子函数中动态注册依赖组件：\n1 2 3 beforeCreate(){ this.$options.components.AnotherComponent=require(\u0026#34;./another-component.vue\u0026#34;).default } 2）使用异步组件加载：\n参考Vue 2 动态组件和异步组件一文。\n模板定义的新方式 通常，我们使用组件内的template选项定义模板字符串，或者在.vue文件的\u0026lt;template\u0026gt;元素中定义模板。\n1.内联模板\n如果在子组件上添加inline-template attribute，那么子组件将使用其内部内容作为模板，而不会将其作为插槽内容。\n1 2 3 4 5 \u0026lt;child-component inline-template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!--模板内容--\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/child-component\u0026gt; 2.X-Template\n1 2 3 4 5 \u0026lt;script type=\u0026#34;text/x-template\u0026#34; id=\u0026#34;my-template\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!--模板内容--\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/script\u0026gt; 1 2 3 Vue.component(\u0026#39;my-component\u0026#39;,{ template:\u0026#39;#my-template\u0026#39; }) 这两种方式适用于我们做做Demo或很小的项目。\n控制更新 控制更新指强制更新和阻止更新。\n1.强制更新\n使用$forceUpdate方法强制更新一个组件，即使没有任何状态变化也会触发重新渲染。\n不过，只有调用它的组件实例及该实例中的子组件的插槽内容会被强制更新，子组件本身不受影响。\n通过递归算法可以强制更新整个组件树：\n1 2 3 4 5 6 function foreceUpdateRecursive(vm){ vm.$forceUpdate() vm.$children.forEach(child=\u0026gt;{ foreceUpdateRecursive(child) }) } 2.阻止更新：使用v-once创建低开销的静态组件\n静态意味着数据不再改变，也就不用重新渲染。\nv-once保证了只渲染该元素和其子元素一次，且将它们的数据缓存起来。\n","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/vue-2%E5%A4%84%E7%90%86%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5/","title":"【Vue 2】处理边界情况"},{"content":"在Vue中使用v-for渲染列表时，默认使用就地更新策略。该策略默认是基于索引的，规定在列表绑定的数据元素顺序变化时，不会重新创建整个列表，而只是更新对应DOM元素上的数据。以下代码实现了一个TODO列表的勾选、添加和删除功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;In-Place Update Example\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(todo, index) in todos\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;todo.completed\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;button @click=\u0026#34;removeTodo(index)\u0026#34;\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;button @click=\u0026#34;addTodo\u0026#34;\u0026gt;Add Todo\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { todos: [ { text: \u0026#39;Learn Vue.js\u0026#39;, completed: false }, { text: \u0026#39;Build an app\u0026#39;, completed: true }, { text: \u0026#39;Deploy to production\u0026#39;, completed: false } ] }, methods: { removeTodo(index) { this.todos.splice(index, 1); }, addTodo() { this.todos.push({ text: \u0026#39;New Todo\u0026#39;, completed: false }); } } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 该策略模式是高效的，避免了大量的DOM重排重绘。\n然而，该策略基于一个前提：列表项内部的内容不依赖于子组件的状态或临时的DOM状态。如违背该前提，就可能导致意外，因为Vue不会重新创建子组件或恢复临时DOM状态。\n下面代码实现了v-for列表项内容依赖于子组件的状态而导致意外的情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;In-Place Update with Child Component\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 使用 v-for 渲染子组件列表 --\u0026gt; \u0026lt;child-component v-for=\u0026#34;(item, index) in itemList\u0026#34; :key=\u0026#34;index\u0026#34; @remove=\u0026#34;removeItem(index)\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;child-component\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;!-- 子组件的内容和状态 --\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;{{ count }}\u0026lt;/button\u0026gt; \u0026lt;!-- 删除 --\u0026gt; \u0026lt;button @click=\u0026#34;$emit(\u0026#39;remove\u0026#39;)\u0026#34;\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; `, methods: { increment() { this.count++; } }, data(){ return{ count:0 } } }); const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { itemList: new Array(5).fill(null) }, methods: { removeItem(index) { this.itemList.splice(index, 1); } } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 我们先点击某项计数器，再删除该项：\n为了解决该问题，我们为每一项绑定一个唯一的key属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;In-Place Update with Child Component\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 使用 v-for 渲染子组件列表 --\u0026gt; \u0026lt;child-component v-for=\u0026#34;(item, index) in itemList\u0026#34; :key=\u0026#34;item.id\u0026#34; @remove=\u0026#34;removeItem(index)\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;child-component\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;!-- 子组件的内容和状态 --\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;{{ count }}\u0026lt;/button\u0026gt; \u0026lt;!-- 删除 --\u0026gt; \u0026lt;button @click=\u0026#34;$emit(\u0026#39;remove\u0026#39;)\u0026#34;\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; `, methods: { increment() { this.count++; } }, data(){ return{ count:0 } } }); const app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { // 为每一项添加一个id itemList: [ { id: 0 }, { id: 1 }, { id: 2 } ] }, methods: { removeItem(index) { this.itemList.splice(index, 1); } } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果如下：\n那么就有疑问了：为什么前面代码中的key属性绑定了index没有用呢，index难道不是唯一的吗？很简单，这是由于我们删除的是数据项，而不是数组索引，使用id就不会有这个问题，删除一项连带着删除了该唯一id。\n","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/vue-2%E5%B0%B1%E5%9C%B0%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/","title":"【Vue 2】就地更新策略"},{"content":"new Vue() 每个Vue应用都是通过new Vue()创建一个Vue实例开始。\nVue()函数可以传入选项Options，常见的有el、template和data选项等。\nel只在new创建实例时生效，其值可以是一个CSS选择器或一个HTML Element实例。实例挂载后（mounted之后）可通过vm.$el访问，如果开始实例化时不给el选项，则需要调用vm.$mount指定挂载点。挂载元素会被编译后生成的DOM替换掉。 template定义组件的模板，即要渲染的内容。 data选项的值是对象类型，它的property会被Vue实例所代理，成为响应式数据，拥有双向改变的特性。只有在创建时data中的属性property才会被响应式化。 Vue()的具体实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 import {initMixin} from \u0026#39;./init\u0026#39; function Vue(options){ //安全性检查：是否为非生产环境且this是否是Vue的实例 //如果是非生产环境且this不是Vue的实例，即没有通过使用new实例化Vue if(process.env.NODE_ENV!==\u0026#39;production\u0026#39;\u0026amp;\u0026amp;!(this instanceof Vue)){ warn(\u0026#39;Vue is a constructor and should be called with the `new` keyword\u0026#39;) } //⭐ this._init(options) } initMixin(Vue) export default Vue _init方法是整个初始化流程的开始。\ninitMixin方法向Vue构造函数的原型prototype挂载一些方法，_init便是其中之一。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 export function initMixin(Vue){ //在Vue的构造函数的原型上添加一个_init方法 Vue.prototype._init=function(options){ //合并构造函数的选项和用户传入的选项并挂载到Vue实例vm的$options选项上 vm.$options=mergeOptions( resolveConstructorOptions(vm.constructor), options||{}, vm ) //依次初始化 initLifecycle(vm)\t//初始化组件的生命周期 initEvents(vm)\t//初始化事件 initRender(vm)\t//初始化渲染函数 callHook(vm,\u0026#39;beforeCreate\u0026#39;)\t//调用beforeCreate生命周期钩子函数 initInjections(vm)\t//初始化注入，处理inject选项 initState(vm)\t//初始化状态，包括data、props、methods、computed、watch initProvide(vm)\t//初始化provide，处理provide选项 callHook(vm,\u0026#39;created\u0026#39;)\t//调用created生命周期钩子函数 //⭐如果有挂载的目标元素 if(vm.$options.el){ //挂载实例到目标元素上 vm.$mount(vm.$options.el) } } } Vue生命周期图 每个Vue实例在创建时都要经过一系列过程：初始化、模板编译、挂载、卸载这四个阶段。阶段之间会陆续执行一类函数，称为生命周期函数。如下图所示：\nVue生命周期图\n生命周期阶段 new Vue()到created的阶段是初始化阶段，该阶段会初始化属性props、事件events和响应式数据data，还有computed、watch、provide和inject。\ncreated到beforeMount的阶段是模板编译阶段，明显Vue的运行时版本不包含该阶段，只存在于完整版Vue中。运行时版本的Vue.js需要搭配其他构建工具如vue-loader等来预编译Vue模板。模板编译即通过编译器将模板代码转换成javascript代码。\nbeforeMount到mounted阶段是挂载阶段，挂载阶段也是Vue生命周期中占时通常最长的一个阶段。挂载的意思是指Vue.js将其实例挂载到指定的DOM元素上，也就是用编译后的模板代码替换指定DOM元素的内部内容，实现模板内容的渲染。同时，Vue.js会启用Watcher来跟踪依赖的变化。一个状态所绑定的依赖是指一个组件。挂载阶段的原理和vm.$mount方法息息相关。\n在挂载阶段，数据（状态）发生变化后，Watcher会通知虚拟DOM重新渲染，新DOM将替换旧DOM，从beforeUpdate函数执行后到updated函数结束前是页面重渲染阶段。\n最后的卸载阶段，Vue调用vm.$destroy方法来销毁自身。\n生命周期Demo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; Vue.config.productionTip = false; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;span\u0026gt;点击了{{count}}次\u0026lt;/span\u0026gt; \u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt;加1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;$destroy()\u0026#34;\u0026gt;销毁\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm=new Vue({ el:\u0026#34;#app\u0026#34;, data:{ count:0 }, beforeCreate(){ console.log(\u0026#34;beforeCreate\u0026#34;); }, created() { console.log(\u0026#34;created\u0026#34;); }, beforeMount(){ console.log(\u0026#34;beforeMount\u0026#34;); }, mounted(){ console.log(\u0026#34;mounted\u0026#34;); }, beforeUpdate() { console.log(\u0026#34;beforeUpdate\u0026#34;); }, updated() { console.log(\u0026#34;updated\u0026#34;); }, beforeDestroy() { console.log(\u0026#34;beforeDestroy\u0026#34;); }, destroyed() { console.log(\u0026#34;destroyed\u0026#34;); }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 面试相关问题 1.最早什么时候可以操作DOM？\n最早可以在mounted中操作DOM，因为执行mounted时编译模板已被挂载到DOM元素上。\n2.最早什么时候可以使用响应式数据？\n由生命周期图上可知，响应式数据初始化在beforeCreate到created之间，所以我们最早可以在created访问响应式数据。\n3.第一次页面加载会触发哪些生命周期钩子\nbeforeCreate、created、beforeMount、mounted\n4.父子组件的生命周期执行过程\n父组件执行到beforeMount，子组件开始执行生命周期，子组件挂载完成后，父组件开始挂载，父组件挂载完成后，会执行一次更新过程，也就是beforeUpdate、updated。\n参考资料 深入浅出Vue.js vue面试题之一：生命周期函数面试题 ","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/vue-2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","title":"【Vue 2】生命周期"},{"content":"简单的组件示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button-counter\u0026gt;\u0026lt;/button-counter\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;button-counter\u0026#39;, { template: `\u0026lt;button v-on:click=\u0026#34;addCount\u0026#34;\u0026gt;你点击了我{{count}}次\u0026lt;/button\u0026gt;`, data() { return { count: 0 } }, methods: { addCount() { this.count++; } }, }) var app = new Vue({ el: \u0026#39;#app\u0026#39;, }) \u0026lt;/script\u0026gt; 组件是可任意次数复用的Vue实例，所以它与new Vue()接收相同选项，但是data必须是一个函数，以确保不同组件不会共享数据。 Vue.component用于全局注册一个组件。 每个组件必需有且只有一个根元素。 全局注册组件必须在vue实例化之前，否则组件注册不成功。 使用事件抛出值 主要是$emit和$event\n1 2 3 4 5 //在子组件里使用 @eventName=\u0026#34;$emit(\u0026#39;customeEventName\u0026#39;,thrown value)\u0026#34; //在父组件里，如果下面是使用表达式，则可以通过 $event 获取 thrown value；如果使用函数的话，则该函数的第一个参数为 thrown value \u0026lt;child-component @customeEventName=\u0026#34;JS statement or a function\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; 使用prop向子组件传值 注册子组件\n1 2 3 4 5 6 7 8 Vue.component(\u0026#34;child-component\u0026#34;,{ //定义prop props:[\u0026#39;propName\u0026#39;], template: ` ... ` }) 传值给子组件props数组里的prop\n1 \u0026lt;child-component propName=\u0026#34;字符串\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; 如果prop绑定的是动态值（比如data里的数据）那么就使用v-bind绑定\n1 \u0026lt;child-component v-bind:propName=\u0026#34;动态值\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; 在组件上使用v-model 最常见的：\n1 \u0026lt;input v-model=\u0026#34;inputText\u0026#34;\u0026gt; 它等价于：\n1 \u0026lt;input v-bind:value=\u0026#34;inputText\u0026#34; v-on:input=\u0026#34;inputText=$event.target.value\u0026#34;\u0026gt; 如果是自定义组件，如custom-input：\n1 2 3 \u0026lt;custom-input v-model=\u0026#34;inputText\u0026#34;\u0026gt; // 等价于 \u0026lt;custom-input v-bind:value=\u0026#34;inputText\u0026#34; v-on:input=\u0026#34;inputText=$event\u0026#34;\u0026gt;\u0026lt;/custom-input\u0026gt; v-bind:value=\u0026quot;inputText\u0026quot;实现了inputText改变，则value改变，\nv-on:input=\u0026quot;inputText=$event\u0026quot;实现了value改变，则inputText改变。\n简单了解通过插槽分发内容 插槽用于将组件将内容分发到特定位置，换句话说，允许你在父组件中传递内容到子组件，并且子组件可以决定如何显示这些内容。\n假如有一个custom-button组件，我们希望可以自定义其名称。\n1 2 3 4 5 6 7 8 Vue.component(\u0026#39;custom-button\u0026#39;,{ template: ` \u0026lt;button\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/button\u0026gt; ` }) 然后我们可以在父组件中这样传递内容：\n1 2 3 \u0026lt;custom-button\u0026gt; Click me! \u0026lt;/custom-button\u0026gt; Click me!就会被插入到slot的位置。\n初步了解动态组件 动态组件值在一个挂载点可以切换多个组件，类似于tab页的切换。\nVue使用\u0026lt;component\u0026gt;元素加上is attribute来实现动态组件，is可绑定的值包括已注册组件名或一个组件的选项对象。\n一个动态组件的例子如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;type=type===\u0026#39;first\u0026#39;?\u0026#39;second\u0026#39;:\u0026#39;first\u0026#39;\u0026#34;\u0026gt;{{type}}\u0026lt;/button\u0026gt; \u0026lt;component :is=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;first\u0026#39;, { template: `\u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;1\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt;`, }) Vue.component(\u0026#39;second\u0026#39;, { template: `\u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;2\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt;`, }) var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { type: \u0026#39;first\u0026#39; } }) \u0026lt;/script\u0026gt; 解析DOM模板时的注意事项 ul、ol、table、select这些元素只允许某些特定的元素出现在其内部，\n如果像下面这样\n1 2 3 \u0026lt;table\u0026gt; \u0026lt;child-component\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/table\u0026gt; 则会导致渲染出错\n比如下面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;demo\u0026gt;\u0026lt;/demo\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;demo\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;demo\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; `, }) var app = new Vue({ el: \u0026#39;#app\u0026#39;, }) \u0026lt;/script\u0026gt; 虽然显示结果与我们预期的一样，但是F12查看发现，demo组件内容被提到了table元素的上面：\n对于这种情况，我们可以使用前文动态组件中介绍的is属性来解决：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr :is=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; ... var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { type: \u0026#39;demo\u0026#39; } }) \u0026lt;/script\u0026gt; 需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的：\n字符串 (例如：template: '...') 单文件组件 (.vue) \u0026lt;script type=\u0026quot;text/x-template\u0026quot;\u0026gt; ","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/vue-2%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/","title":"【Vue 2】组件基础"},{"content":"1 组件名的命名规则 定义组件名的两种方式：\n短横线分隔命名，Kebab Case，例如my-component-name。 单词首字母大写命名，Pascal Case，例如MyComponentName。 第一种方式在模板中使用\u0026lt;my-component-name\u0026gt;引用该元素，第二种方式可以使用\u0026lt;my-component-name\u0026gt;或\u0026lt;MyComponentName\u0026gt;。\n2 全局注册和局部注册 在组件基础一文中我们提到Vue.component这种组件注册方式是全局注册的。\n全局注册意味着它们可以在其他Vue实例中直接使用。\n但有时对于某个全局注册的组件，我们并不是很频繁地使用，或者我们不再需要这个组件，但它仍会被包含在构建结果中。\n于是我们可以采用局部注册的方式。\n不采用模块系统的局部注册：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;component-a\u0026gt;\u0026lt;/component-a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var ComponentA = { template: \u0026#39;\u0026lt;div\u0026gt;Component A\u0026lt;/div\u0026gt;\u0026#39; }; new Vue({ el: \u0026#39;#app\u0026#39;, components: { \u0026#39;component-a\u0026#39;: ComponentA }, }); \u0026lt;/script\u0026gt; 如果你通过 Babel 和 webpack 使用 ES2015 模块，可以像下面这样进行局部注册：\n1 2 3 4 5 6 7 import ComponentA from \u0026#39;./ComponentA\u0026#39; export default{ components:{ ComponentA //ComponentA:ComponentA的缩写 } } 当然，在模块化系统中，我们也可以进行全局注册，除了使用之前提到的Vue.component，还可以在使用了webpack或Vue CLI 3+的前提下，使用require.context进行全局注册：\nmain.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import upperFirst from \u0026#39;lodash/upperFirst\u0026#39; import camelCase from \u0026#39;lodash/camelCase\u0026#39; const requireComponent=require.context( \u0026#39;./components\u0026#39;,//基础组件相对路径 false,//是否递归查询其子目录 /Base[A-Z]\\w+.(vue|js)$/ //基础文件名的正则表达式 ) requireComponent.keys().forEach(fileName=\u0026gt;{ //获取组件配置 const compoentConfig=requireComponent(fileName) //获取组件的PascalCase命名 const componentName=upperFirst(//大写首字母 camelCase(//转换字符串string为驼峰写法 //获取与目录深度无关的文件名 fileName .split(\u0026#39;/\u0026#39;) .pop() .replace(/\\.\\w+$/,\u0026#39;\u0026#39;) ) ) //全局注册组件 Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的， // 那么就会优先使用 `.default`， // 否则回退到使用模块的根。 componentConfig.default || componentConfig ) }) //阻止Vue在启动时生成生产提示，如下： //You are running Vue in development mode. //Make sure to turn on production mode when deploying for production. //See more tips at https://vuejs.org/guide/deployment.html Vue.config.productionTip=false new Vue({ //从App提供的模板编译渲染函数 //h代指createElement方法，接收根组件App来创建VNode render:h=\u0026gt;h(App) }).$mount(\u0026#39;#app\u0026#39;) //手动挂载 Vue.component用于全局注册单个组件，上面方法用于全局注册多个组件，所以会多次调用Vue.component方法。\n额外话题\n作者发现了Vue.config.productionTip=false在某些位置不生效的情况。\n实际上观察Vue检查devtools插件安装情况和开发模式的类型的源码部分可发现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 var inBrowser = typeof window !== \u0026#34;undefined\u0026#34;; .... .... // devtools global hook /* istanbul ignore next */ if (inBrowser) { setTimeout(function () { if (config.devtools) { if (devtools) { devtools.emit(\u0026#39;init\u0026#39;, Vue); } else { console[console.info ? \u0026#39;info\u0026#39; : \u0026#39;log\u0026#39;]( \u0026#39;Download the Vue Devtools extension for a better development experience:\\n\u0026#39; + \u0026#39;https://github.com/vuejs/vue-devtools\u0026#39; ); } } if (config.productionTip !== false \u0026amp;\u0026amp; typeof console !== \u0026#39;undefined\u0026#39; ) { console[console.info ? \u0026#39;info\u0026#39; : \u0026#39;log\u0026#39;]( \u0026#34;You are running Vue in development mode.\\n\u0026#34; + \u0026#34;Make sure to turn on production mode when deploying for production.\\n\u0026#34; + \u0026#34;See more tips at https://vuejs.org/guide/deployment.html\u0026#34; ); } }, 0); } Vue.config.productionTip=false应该在inBrowser为true时就已经被设置好，而inBrowser表示当前是否是浏览器环境，它通过检测window对象是否存在来判断，window对象在页面被渲染后定义。所以，Vue.config.productionTip设置时机是在页面渲染前。body中的script标签是在body解析完后才执行的。换言之，Vue.config.productionTip设置时机是在body解析前。\n","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/vue-2%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/","title":"【Vue 2】组件注册"},{"content":"Vue 自定义指令允许我们在 DOM 元素上添加自己想要的行为来扩展 Vue 的功能。\n一个自定义指令需要一个名称和一个定义对象。在定义对象中，你可以使用一些钩子函数来控制指令的行为：\nbind：在指令被绑定到元素上时使用，只调用一次。可以用来初始化一些值。 inserted：在被绑定元素插入父节点时调用。可以用来执行初始的DOM操作，比如设置焦点/绑定事件。 update：在被绑定元素的值更新时调用，无论绑定值是否改变。可以用来响应值的更新。可能发生在其子VNode更新之前。 componentUpdated：指令所在组件的VNode及其子VNode全部更新后调用。 unbind：指令与元素解绑时调用，清除绑定的一些事件监听器。 下面给出一个简单的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vue Custom Directive Demo\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input v-model=\u0026#34;colorValue\u0026#34; v-change-color style=\u0026#34;width: 50px;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.directive(\u0026#39;change-color\u0026#39;, { inserted: function (el) { el.addEventListener(\u0026#39;input\u0026#39;, function () { el.style.color = el.value }) } }) var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { colorValue: \u0026#39;black\u0026#39; } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Vue自定义指令的钩子函数接受一些参数，这些参数提供了有关指令的上下文信息及对应的DOM元素：\nbind(el,binding,vnode): el：绑定指令的元素。 binding：一个对象，包含以下属性： name：指令名称，不包括v-前缀。 value：指令的绑定值，可以是一个表达式或变量。 oldValue：指令之前的绑定值。 expression：绑定值的表达式字符串形式。 arg：指令参数，例如v-my-directive:arg中的arg。 modifiers：修饰符对象，例如v-my-directive.modifier1.modifier2中，修饰符对象为{modifier1:true,modifier2:true}。 vnode：Vue编译生成的虚拟节点。 inserted(el,binding,vnode) update(el,binding,vnode,oldVnode): oldVnode：之前的虚拟节点，用于比较更新。 componentUpdated(el,binding,vnode,oldVnode) unbind(el,binding,vnode) 我们也可以使用v-my-directive:[arg]=\u0026quot;value\u0026quot;的形式来使用动态参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vue Custom Directive with Dynamic Argument\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p v-mydirective:[arg1]\u0026gt;Hello World\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.directive(\u0026#39;mydirective\u0026#39;, { bind: function(el, binding, vnode) { console.log(binding.arg); el.style[binding.arg] = \u0026#39;5px solid red\u0026#39;; } }); var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { arg1: \u0026#39;border\u0026#39; } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; bind和update的函数简写\n同时定义bind和update而不考虑其他钩子函数：\n1 2 3 Vue.directive(\u0026#39;mydirective\u0026#39;,function(el,binding){ //... }) ","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/vue-2%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","title":"【Vue 2】自定义指令"},{"content":"计算属性 vs 方法 vs 侦听器 计算属性的出现是为了解决模板内表达式太过复杂而变得难以维护。\n假设我们知道长和宽，要计算一个矩形的面积，如果没有计算属性，我们可能像下面这样处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;width\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;height\u0026#34;\u0026gt; \u0026lt;p\u0026gt;面积是{{area()}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { width:0, height:0 }, methods: { area: function() { return this.width * this.height } }, }) \u0026lt;/script\u0026gt; 使用计算属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;width\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;height\u0026#34;\u0026gt; \u0026lt;p\u0026gt;面积是{{area}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { width:0, height:0 }, computed:{ area:function(){ return this.width*this.height } } }) \u0026lt;/script\u0026gt; 它们的区别是，使用methods需要每次获取值都调用该方法，使用computed会将值缓存，只在它的响应式依赖变化时才会重新计算。\n侦听器watch和计算属性一样都会监听数据的变化，但是，对于要监听的属性，侦听器需要给它们每一个都单独设置响应函数，计算属性则只需按需设置，例如上面的例子使用侦听器的话：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;width\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;height\u0026#34;\u0026gt; \u0026lt;p\u0026gt;面积是{{area}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { width:0, height:0, area:0 }, watch:{ width:function(newVal){ this.area = newVal * this.height }, height:function(newVal){ this.area = newVal * this.width } } }) \u0026lt;/script\u0026gt; 这样会显得重复冗余。\n所以，计算属性适用于基于一种或多种属性计算出派生值的情况，例如计算面积、价格等，也适用于需要进行一些复杂的数据处理和转换；侦听器适用于监听属性的变化，然后执行一些异步操作（例如API调用）、更新其他属性或自定义逻辑（例如数据变化时的动态效果）。\n计算属性的getter与setter 计算属性默认是getter，我们也可以设置其setter。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Base Count: {{ baseCount }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Current Count: {{ count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;incrementCount\u0026#34;\u0026gt;Increment Count\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;incrementBaseCount\u0026#34;\u0026gt;Increment Base Count\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { baseCount: 5 }, computed: { count: { // Getter function get: function () { return this.baseCount * 2; }, // Setter function set: function (newCount) { this.baseCount = newCount / 2; } } }, methods: { incrementCount: function () { this.count++; }, incrementBaseCount: function () { this.baseCount++; } } }); \u0026lt;/script\u0026gt; 参考资料 计算属性和侦听器 ","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/vue-2%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%99%A8/","title":"【Vue 2】计算属性与侦听器"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi),e^{2 \\pi i \\xi x},d\\xi $$\n1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"http://localhost:1313/p/math-typesetting/","title":"Math Typesetting"}]