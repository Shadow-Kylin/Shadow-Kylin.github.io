[{"content":"Service Worker 简介 Service Worker 是一种 Web 技术，是运行在用户浏览器背景中的 JavaScript 文件。它提供了拦截和处理网络请求（HTTPS 环境下）的能力，允许开发者缓存资源并创建离线体验，同时还能支持推送通知和后台数据同步等功能。\nService Worker 的重要特性 独立线程 Service Worker 在浏览器的单独线程中运行，与主线程分离，不直接访问 DOM，但可以通过 postMessage 与主线程通信。\n生命周期 安装（install）：当浏览器检测到新的 Service Worker 脚本时，进入安装阶段。 激活（activate）：新 Service Worker 安装完成后，清理旧缓存或其他不需要的资源。 运行（fetch 等事件）：处理网络请求或提供离线内容。 相关事件 （1）install 事件，在 Serive Worker 首次安装时触发，用于预缓存资源。\n1 2 3 4 5 6 7 self.addEventListener(\u0026#39;install\u0026#39;, event =\u0026gt; { event.waitUntil( caches.open(\u0026#39;my-cache\u0026#39;).then(cache =\u0026gt; { return cache.addAll([\u0026#39;/index.html\u0026#39;, \u0026#39;/styles.css\u0026#39;, \u0026#39;/script.js\u0026#39;]); }) ); }); （2）activate 事件，在 Serive Worker 激活时触发，用于清理旧缓存。\n（3）fetch 事件，拦截网络请求时触发，用于返回缓存资源或动态请求。\n（4）push 事件，与 Push API 结合，实现实时通知。\n（5）sync 事件，用于后台同步操作（需要注册 Background Sync）。\n（6）notificationclick 事件，当用户点击通知时触发。\nService Worker 主要 API event.waitUntil event.waitUntil 是 Service Worker 中的一种关键方法，用于确保在事件的生命周期内，异步任务完成之前事件不会终止。\nevent.respondWith event.respondWith 是 Service Worker 中专门用于拦截和处理网络请求的 API。它允许开发者接管浏览器对资源的默认请求和响应行为，并根据需要返回缓存、网络请求或其他自定义响应。（与缓存策略挂钩）\nCache API Cache API 提供了对缓存资源的读写操作，主要用于实现离线支持。\n（1）caches.open(cacheName)\n打开或创建一个缓存对象。\n1 2 3 caches.open(\u0026#39;my-cache\u0026#39;).then(cache =\u0026gt; { cache.addAll([\u0026#39;/index.html\u0026#39;, \u0026#39;/styles.css\u0026#39;, \u0026#39;/script.js\u0026#39;]); }); （2）caches.match(request)\n查找是否存在与请求匹配的缓存。\n1 2 3 4 5 6 7 caches.match(\u0026#39;/index.html\u0026#39;).then(response =\u0026gt; { if (response) { return response; // 返回缓存 } else { return fetch(\u0026#39;/index.html\u0026#39;); // 请求网络 } }); （3）caches.keys()\n获取所有缓存名称。\n1 2 3 caches.keys().then(keys =\u0026gt; { console.log(keys); // 输出缓存名称数组 }); （4）caches.delete(cacheName)\n删除指定缓存。\n1 2 3 caches.delete(\u0026#39;old-cache\u0026#39;).then(success =\u0026gt; { if (success) console.log(\u0026#39;缓存删除成功\u0026#39;); }); Fetch API Fetch API 用于拦截网络请求并自定义响应。结合 Service Worker 的 fetch 事件使用。\n1 2 3 4 5 6 7 self.addEventListener(\u0026#39;fetch\u0026#39;, event =\u0026gt; { event.respondWith( caches.match(event.request).then(response =\u0026gt; { return response || fetch(event.request); // 返回缓存或网络请求 }) ); }); Clients API Clients API 用于与 Service Worker 的页面或其他上下文通信。\n（1）clients.matchAll()\n获取与 Service Worker 关联的所有客户端（浏览器窗口或标签页）。\n1 2 3 4 5 clients.matchAll().then(clientList =\u0026gt; { clientList.forEach(client =\u0026gt; { console.log(\u0026#39;客户端 URL:\u0026#39;, client.url); }); }); （2）clients.openWindow(url)\n打开一个新窗口或标签页。\n1 2 3 self.addEventListener(\u0026#39;notificationclick\u0026#39;, event =\u0026gt; { event.waitUntil(clients.openWindow(\u0026#39;/new-page\u0026#39;)); }); （3）client.postMessage(message)\n向特定客户端发送消息。\n1 2 3 clients.matchAll().then(clientList =\u0026gt; { clientList[0].postMessage({ message: \u0026#39;Hello from Service Worker!\u0026#39; }); }); Notification API Notification API 用于显示通知，与 push 事件结合使用。\n（1）显示通知\n在 Service Worker 中触发通知显示。\n1 2 3 4 5 self.registration.showNotification(\u0026#39;标题\u0026#39;, { body: \u0026#39;这是通知的正文\u0026#39;, icon: \u0026#39;/icon.png\u0026#39;, badge: \u0026#39;/badge.png\u0026#39; }); self.registration 是 Service Worker 的注册对象。\n在主线程显示通知：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if (\u0026#34;Notification\u0026#34; in window) { console.log(\u0026#34;浏览器支持 Notification\u0026#34;); Notification.requestPermission().then((permission) =\u0026gt; { if (permission === \u0026#34;granted\u0026#34;) { const options = { body: \u0026#34;新消息通知\u0026#34;, icon: \u0026#34;icon.png\u0026#34;, tag: \u0026#34;unique-tag\u0026#34;, }; const notification = new Notification(\u0026#34;您有新消息\u0026#34;, options); notification.onclick = () =\u0026gt; { console.log(\u0026#34;用户点击了通知\u0026#34;); window.open(\u0026#34;https://example.com\u0026#34;); }; } }); } （2）通知事件\n用户点击通知时触发，通常用于跳转或执行操作。\n1 2 3 4 self.addEventListener(\u0026#39;notificationclick\u0026#39;, event =\u0026gt; { event.notification.close(); // 关闭通知 event.waitUntil(clients.openWindow(\u0026#39;/target-page\u0026#39;)); }); Sync API Sync API 用于在网络恢复时执行后台任务，例如发送离线数据。\n（1）注册后台同步任务\n需要在主线程注册任务。\n1 2 3 navigator.serviceWorker.ready.then(sw =\u0026gt; { sw.sync.register(\u0026#39;sync-tag\u0026#39;); }); （2）处理同步事件——监听 sync 事件\n1 2 3 4 5 6 7 8 self.addEventListener(\u0026#39;sync\u0026#39;, event =\u0026gt; { if (event.tag === \u0026#39;sync-tag\u0026#39;) { event.waitUntil( // 执行后台任务 fetch(\u0026#39;/sync-endpoint\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: JSON.stringify({ key: \u0026#39;value\u0026#39; }) }) ); } }); Service Worker 注册和控制 API 这些 API 在主线程中使用，用于注册和管理 Service Worker。\n（1）navigator.serviceWorker.register(scriptURL)：注册 Service Worker 脚本。\n1 2 3 navigator.serviceWorker.register(\u0026#39;/service-worker.js\u0026#39;).then(registration =\u0026gt; { console.log(\u0026#39;Service Worker 注册成功:\u0026#39;, registration); }); （2）navigator.serviceWorker.ready：返回一个 Promise，解析为 Service Worker 的控制对象。\n1 2 3 navigator.serviceWorker.ready.then(sw =\u0026gt; { console.log(\u0026#39;Service Worker 已就绪\u0026#39;); }); （3）navigator.serviceWorker.controller：获取当前页面的控制 Service Worker。\n1 2 3 if (navigator.serviceWorker.controller) { console.log(\u0026#39;当前页面由 Service Worker 控制\u0026#39;); } IndexedDB API 虽然不是 Service Worker 专属，但常与其结合用于存储离线数据。\n（1）创建和使用数据库\n1 2 3 4 5 const request = indexedDB.open(\u0026#39;my-database\u0026#39;, 1); request.onsuccess = event =\u0026gt; { const db = event.target.result; console.log(\u0026#39;数据库连接成功:\u0026#39;, db); }; （2）\n使用 Service Worker 的步骤 创建 Service Worker 文件 创建一个名为 service-worker.js 的文件，这是 Service Worker 的主脚本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // 缓存版本 const CACHE_NAME = \u0026#39;v1\u0026#39;; // 要缓存的资源，路径相对于当前目录 const CACHE_ASSETS = [ \u0026#39;/\u0026#39;, \u0026#39;/index.html\u0026#39;, \u0026#39;/styles.css\u0026#39;, \u0026#39;/app.js\u0026#39;, \u0026#39;/logo.png\u0026#39;, ]; // 安装事件：缓存静态资源 self.addEventListener(\u0026#34;install\u0026#34;, (event) =\u0026gt; { console.log(\u0026#34;Service Worker: Installing...\u0026#34;); self.skipWaiting(); // 跳过等待，直接进入激活状态 event.waitUntil( caches.open(CACHE_NAME).then((cache) =\u0026gt; { console.log(\u0026#34;Service Worker: Caching Files\u0026#34;); return cache.addAll(CACHE_ASSETS); }) ); }); // 激活事件：清理旧的缓存 self.addEventListener(\u0026#34;activate\u0026#34;, (event) =\u0026gt; { console.log(\u0026#34;Service Worker: Activating...\u0026#34;); event.waitUntil( caches.keys().then((cacheNames) =\u0026gt; { return Promise.all( cacheNames.map((cacheName) =\u0026gt; { if (cacheName !== CACHE_NAME) { console.log(\u0026#34;Service Worker: Clearing Old Cache\u0026#34;); return caches.delete(cache); } }) ); }) ); self.clients.claim(); // 立即接管页面控制权 }); // 拦截请求并返回缓存资源 self.addEventListener(\u0026#39;fetch\u0026#39;, event =\u0026gt; { console.log(\u0026#39;Service Worker: Fetching\u0026#39;, event.request.url); event.respondWith( caches.match(event.request).then(response =\u0026gt; { // 如果资源在缓存中，则返回缓存，否则发起网络请求 return response || fetch(event.request); }) ); }); 文件结构\n1 2 3 4 5 6 /project ├── index.html ├── styles.css ├── app.js ├── logo.png └── service-worker.js 注册 Service Worker 在你的主 JavaScript 文件中（如 main.js），注册 Service Worker。\n1 2 3 4 5 6 7 8 9 10 11 12 if (\u0026#39;serviceWorker\u0026#39; in navigator) { window.addEventListener(\u0026#39;load\u0026#39;, () =\u0026gt; { navigator.serviceWorker .register(\u0026#39;/service-worker.js\u0026#39;) // 路径相对于根目录 .then(registration =\u0026gt; { console.log(\u0026#39;Service Worker registered with scope:\u0026#39;, registration.scope); }) .catch(err =\u0026gt; { console.error(\u0026#39;Service Worker registration failed:\u0026#39;, err); }); }); } 确保 HTTPS 环境 Service Worker 只能在安全上下文（HTTPS 或 localhost）中工作。如果使用本地开发环境，可以用 http-server 或 lite-server 等工具运行本地服务器。\n1 npx http-server 缓存策略 根据你的应用需求，可以选择不同的缓存策略。\n缓存优先策略 如果优先使用缓存，可以修改 fetch 事件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 self.addEventListener(\u0026#39;fetch\u0026#39;, event =\u0026gt; { event.respondWith( caches.match(event.request).then(cachedResponse =\u0026gt; { return cachedResponse || fetch(event.request).then(networkResponse =\u0026gt; { // 将网络请求的响应缓存起来 return caches.open(CACHE_NAME).then(cache =\u0026gt; { cache.put(event.request, networkResponse.clone()); return networkResponse; }); }); }) ); }); 网络优先策略 如果需要优先从网络获取最新数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 self.addEventListener(\u0026#39;fetch\u0026#39;, event =\u0026gt; { event.respondWith( fetch(event.request) .then(networkResponse =\u0026gt; { // 将响应数据缓存起来 return caches.open(CACHE_NAME).then(cache =\u0026gt; { cache.put(event.request, networkResponse.clone()); return networkResponse; }); }) .catch(() =\u0026gt; caches.match(event.request)) // 如果网络请求失败，则使用缓存 ); }); 离线回退（Offline Fallback） 当网络和缓存都不可用时，返回一个备用的离线页面。\n1 2 3 4 5 6 7 8 9 self.addEventListener(\u0026#39;fetch\u0026#39;, event =\u0026gt; { event.respondWith( caches.match(event.request).then(response =\u0026gt; { return response || fetch(event.request).catch(() =\u0026gt; { return caches.match(\u0026#39;/offline.html\u0026#39;); // 返回离线页面 }); }) ); }); 更新 Service Worker 当你需要更新 Service Worker 的脚本时，浏览器会检测文件的变化，并进入新的安装阶段。 为了让新版本立即生效，可以在 activate 事件中强制控制权交给新版本：\n1 2 3 self.addEventListener(\u0026#39;activate\u0026#39;, event =\u0026gt; { event.waitUntil(self.clients.claim()); // 立即控制页面 }); 调试与测试 检查 Service Worker 状态： 在浏览器的开发者工具中，进入 Application -\u0026gt; Service Workers 查看状态。 模拟离线模式： 在开发者工具中启用离线模式，测试应用是否能在离线状态下正常运行。 清理缓存： 使用 caches.delete() 手动清理旧缓存。 结合 Push API 实现推送通知 Service Worker 的 push 事件和 Push API 是实现 Web 应用实时通知的核心技术。\n当服务器向用户设备发送推送消息时，Service Worker 会监听到 push 事件。\nPush API 工作流程 1.订阅用户（订阅 Push Service）：用户同意接收推送通知后，浏览器通过 Push API 向 Push Service 注册订阅，发送一个包含订阅信息的对象，通常包括 endpoint（推送地址）和 public key（公钥）。\n2.发送推送消息：服务器使用订阅对象中的 endpoint 和加密信息（使用 Web Push Protocol）发送消息。\n3.接收推送消息：浏览器接收消息，并通过触发 Service Worker 的 push 事件将消息交给 Web 应用处理。\n实现步骤 （1）客户端：订阅 Push Service\n用户同意接收通知后，订阅 Push Service。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 注册 Service Worker navigator.serviceWorker.register(\u0026#39;/service-worker.js\u0026#39;).then(registration =\u0026gt; { console.log(\u0026#39;Service Worker 注册成功:\u0026#39;, registration); // 请求用户授权推送通知 return Notification.requestPermission().then(permission =\u0026gt; { if (permission === \u0026#39;granted\u0026#39;) { // 订阅 Push Service return registration.pushManager.subscribe({ userVisibleOnly: true, // 必须设置为 true applicationServerKey: urlBase64ToUint8Array(\u0026#39;\u0026lt;Your-VAPID-Public-Key\u0026gt;\u0026#39;) // 服务器公钥 }); } else { console.log(\u0026#39;通知权限未被授予\u0026#39;); } }); }).then(subscription =\u0026gt; { console.log(\u0026#39;订阅成功:\u0026#39;, JSON.stringify(subscription)); // 将 subscription 发送到服务器 }); （2）服务器：发送推送消息\n服务器使用 Web Push 库（如 web-push）发送消息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const webPush = require(\u0026#39;web-push\u0026#39;); // VAPID 密钥 const vapidKeys = { publicKey: \u0026#39;\u0026lt;Your-VAPID-Public-Key\u0026gt;\u0026#39;, privateKey: \u0026#39;\u0026lt;Your-VAPID-Private-Key\u0026gt;\u0026#39; }; webPush.setVapidDetails( \u0026#39;mailto:example@yourdomain.com\u0026#39;, vapidKeys.publicKey, vapidKeys.privateKey ); // 推送订阅对象 const subscription = { endpoint: \u0026#39;\u0026lt;Browser-Endpoint\u0026gt;\u0026#39;, keys: { p256dh: \u0026#39;\u0026lt;User-Public-Key\u0026gt;\u0026#39;, auth: \u0026#39;\u0026lt;User-Auth-Key\u0026gt;\u0026#39; } }; // 发送推送消息 webPush.sendNotification(subscription, JSON.stringify({ title: \u0026#39;实时通知\u0026#39;, body: \u0026#39;这是一条测试通知！\u0026#39;, url: \u0026#39;/some-url\u0026#39; })).then(response =\u0026gt; { console.log(\u0026#39;推送成功:\u0026#39;, response); }).catch(error =\u0026gt; { console.error(\u0026#39;推送失败:\u0026#39;, error); }); （3）Service Worker 处理 push 事件\n在 Service Worker 中监听 push 事件，并显示通知。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 self.addEventListener(\u0026#39;push\u0026#39;, event =\u0026gt; { console.log(\u0026#39;收到推送消息:\u0026#39;, event); let data = {}; if (event.data) { data = event.data.json(); // 解析推送消息 } const title = data.title || \u0026#39;默认标题\u0026#39;; const options = { body: data.body || \u0026#39;默认消息\u0026#39;, icon: \u0026#39;/icon.png\u0026#39;, badge: \u0026#39;/badge.png\u0026#39;, data: data.url || \u0026#39;/\u0026#39; // 点击通知后跳转的 URL }; event.waitUntil( self.registration.showNotification(title, options) ); }); （4）notificationclick 事件：通知点击处理\n监听通知的点击事件，控制点击行为（如跳转页面或执行操作）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 self.addEventListener(\u0026#39;notificationclick\u0026#39;, event =\u0026gt; { console.log(\u0026#39;通知被点击:\u0026#39;, event); const url = event.notification.data; event.notification.close(); // 关闭通知 // 打开或跳转到指定页面 event.waitUntil( clients.matchAll({ type: \u0026#39;window\u0026#39; }).then(clientList =\u0026gt; { for (const client of clientList) { if (client.url === url \u0026amp;\u0026amp; \u0026#39;focus\u0026#39; in client) { return client.focus(); } } if (clients.openWindow) { return clients.openWindow(url); } }) ); }); 后台同步 通过 Background Sync API 实现可靠的后台任务。\n","date":"2025-01-11T00:53:00+08:00","permalink":"https://demo.stack.jimmycai.com/p/service-worker-api/","title":"Service Worker API"},{"content":"脚本语言 脚本语言是一种解释型编程语言，通常用于控制已有的系统、应用程序或环境（如浏览器、操作系统、游戏引擎）的行为，而不是独立构建一个完整的程序。\n常见脚本语言及其用途：\nWeb 开发脚本： JavaScript：用于浏览器中的动态网页。 PHP：用于服务器端动态网页生成。 通用脚本： Python：广泛应用于数据科学、自动化和服务器端编程。 Ruby：用于开发 Web 应用和脚本任务。 系统脚本： Bash 和 Shell：在 Unix/Linux 系统中，用于任务自动化和脚本控制。 PowerShell：Windows 系统管理工具。 嵌入式脚本： Lua：嵌入到游戏引擎（如 Unity）或应用中。 Tcl：嵌入式脚本工具。 其他： Perl：擅长文本处理和脚本任务。 R：数据分析和统计建模。 ECMAScript 和 JavaScript 的关系 JavaScript 由 Netscape 公司开发，最早在 1995 年发布，它诞生时是一个具体的实现，没有标准化的语言规范。\n1997 年，一种标准化的脚本语言规范 ECMAScript 第一版发布，提供了一套语言的核心特性和语法规则，供脚本语言实现和扩展。\nECMAScript 由 ECMA 国际（ECMA International） 通过其 ECMA-262 标准定义。\nECMAScript 的出现是为了规范化 JavaScript，使其成为一个可以跨平台和跨浏览器统一的脚本语言。\n后来，JavaScript 经过不断发展，不仅实现了 ECMAScript 的规范，还包含了许多 Web 环境相关的特性，例如 DOM 操作和与浏览器的交互 API，所以 JavaScript 和 ECMAScript 是相交关系，而不是包含关系。JavaScript 已经可以用于开发 Web 应用、服务端程序（Node.js）、桌面应用和移动应用。\n其它 ECMAScript 实现还包括 JScript（微软）和 ActionScript（Adobe）。\n总结：ECMAScript 是规范，是理论层面的标准，JavaScript 是 ECMAScript 的具体实现和应用。\nECMAScript 的内容 ECMAScript 仅定义了脚本语言的核心功能和语法规则，包括：\n数据类型 基本类型：undefined, null, boolean, number, bigint, string, symbol。 复杂类型：Object（包括数组、函数等）。 语法规则 变量声明：var, let, const。 控制结构：if, for, while 等。 运算符：算术、比较、逻辑、位运算等。 内置对象 常见对象：Object, Array, Function, Date, RegExp, Map, Set 等。 工具对象：Math, JSON, Promise 等。 函数 函数声明与表达式、箭头函数、默认参数、剩余参数。 类与对象 对象字面量、原型链。 类和继承（从 ES6 引入）。 模块化 导入和导出：import/export（从 ES6 引入）。 异步编程 Promise 和 async/await。 迭代器与生成器 可迭代协议、for\u0026hellip;of。 生成器函数（function*）。 内存管理 垃圾回收（自动回收未引用的对象）。 ","date":"2025-01-10T15:06:00+08:00","permalink":"https://demo.stack.jimmycai.com/p/ecmascript-%E5%92%8C-javascript/","title":"ECMAScript 和 JavaScript"},{"content":"自动垃圾回收 像 C 语言这样的低级语言拥有可手动管理内存的原语（primitive）—— malloc() 和 free()。而 JavaScript 有用于自动管理内存的垃圾回收机制（Garbage Collection, GC）。开发者无需手动分配和释放内存，当创建变量、对象或函数时，JavaScript 会自动分配内存，还会根据垃圾回收算法自动回收不再需要的对象的内存。\n可达性与内存回收 JavaScript 使用可达性来判断一个对象是否需要被保留。根对象是默认可达的，比如全局对象（window）和当前作用域的变量。如果一个对象能通过根对象的引用链访问到，则该对象是可达的，不能被回收。\n常见垃圾回收算法 标记-清理（Mark-and-Sweep） 这是最常见的垃圾回收算法，分为两个阶段：\n标记阶段：从根对象出发，标记所有可达的对象。 清除阶段：清除没有被标记的对象，并回收它们所占的内存。 引用计数（Reference-counting） 每个对象有一个引用计数器，记录有多少引用指向它。如果对象的引用计数变为零，则认为该对象无法被访问，可以回收。\n标记清理的痛点是无法处理循环引用，即两个或多个对象互相引用但从根不可达的情况，这也就会导致它们即使函数执行结束后内存得不到释放。\n1 2 3 4 5 6 function problem() { let objectA = new Object(); let objectB = new Object(); objectA.someOtherObject = objectB; objectB.anotherObject = objectA; } 增量式垃圾回收 将垃圾回收过程拆分为多个小步骤，交替执行垃圾回收和程序执行，避免长时间的暂停。常用于现代 JavaScript 引擎中（如 V8 引擎）。\n分代回收 将内存分为两代：\n新生代：存储生命周期较短的对象（如临时变量）。 老生代：存储生命周期较长的对象（如全局变量）。 新生代对象会更频繁地进行垃圾回收，而老生代对象较少被回收。\nV8 引擎的垃圾回收 Google 的 V8 引擎（用于 Chrome 和 Node.js）结合了多种算法：\n分代垃圾回收：将堆分为新生代和老生代。 Scavenge 算法（新生代）：将活动对象复制到新空间并清空旧空间。 标记-清除和标记-压缩算法（老生代）：用于回收生命周期长的对象。 并行和增量回收：提高垃圾回收的性能，减少主线程的停顿。 内存优化 尽量避免使用全局变量，因为全局变量生命周期长，不易被回收。 及时清理无用引用，避免内存泄漏，可以手动设置对象为 null，帮助垃圾回收器识别。主要注意意外的全局变量、闭包和计时器中的引用。 在使用闭包或 DOM 事件时，避免产生循环引用。 使用 let 或 const 声明变量可以缩小作用域，尽早回收可以回收的内存。 共享隐藏类，避免 JavaScript 中的先创建再补充（ready-fire-aim）式的动态属性赋值，并在构造函数中一次性声明所有可能需要的属性。如果不再需要一个属性值要删除它，可以设其为 null 解除引用，而非直接删除。 使用静态分配的对象池，减少浏览器执行垃圾回收的次数。 ","date":"2025-01-09T18:36:00+08:00","permalink":"https://demo.stack.jimmycai.com/p/javascript-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"JavaScript 内存管理"},{"content":"typeof typeof 适合基础类型的判断。\n缺点：\n无法区分 null 和 object（typeof null === \u0026lsquo;object\u0026rsquo; 是一个设计缺陷）。\n无法区分具体对象类型（如数组和普通对象）。\n1 2 3 4 5 6 7 8 console.log(typeof 123); // \u0026#39;number\u0026#39; console.log(typeof \u0026#39;hello\u0026#39;); // \u0026#39;string\u0026#39; console.log(typeof true); // \u0026#39;boolean\u0026#39; console.log(typeof undefined); // \u0026#39;undefined\u0026#39; console.log(typeof null); // \u0026#39;object\u0026#39; (历史遗留问题) console.log(typeof []); // \u0026#39;object\u0026#39; console.log(typeof {}); // \u0026#39;object\u0026#39; console.log(typeof function(){}); // \u0026#39;function\u0026#39; instanceof instanceof 用于判断对象是否是某个构造函数的实例。\n缺点：\n不适用于原始类型（number、string 等）。 不适用于跨 iframe 或窗口的环境（因为原型链不一致）。 1 2 3 4 5 6 7 console.log([] instanceof Array); // true console.log({} instanceof Object); // true console.log(() =\u0026gt; {} instanceof Function); // true console.log(new Date() instanceof Date); // true // 注意 console.log([] instanceof Object); // true，因为 Array 是 Object 的子类 Object.prototype.toString.call 这是判断具体类型的最常用方法，通过调用对象的 toString 方法返回具体的类型信息。\n1 2 3 4 5 6 7 8 9 console.log(Object.prototype.toString.call(123)); // \u0026#39;[object Number]\u0026#39; console.log(Object.prototype.toString.call(\u0026#39;hello\u0026#39;)); // \u0026#39;[object String]\u0026#39; console.log(Object.prototype.toString.call(true)); // \u0026#39;[object Boolean]\u0026#39; console.log(Object.prototype.toString.call(null)); // \u0026#39;[object Null]\u0026#39; console.log(Object.prototype.toString.call(undefined)); // \u0026#39;[object Undefined]\u0026#39; console.log(Object.prototype.toString.call([])); // \u0026#39;[object Array]\u0026#39; console.log(Object.prototype.toString.call({})); // \u0026#39;[object Object]\u0026#39; console.log(Object.prototype.toString.call(() =\u0026gt; {})); // \u0026#39;[object Function]\u0026#39; console.log(Object.prototype.toString.call(new Date())); // \u0026#39;[object Date]\u0026#39; Array.isArray 这是专门用来判断数组的方法，是 ES5 中新增的。\n值得注意的是，Array.isArray 不会受这种跨窗口的影响，因为它是通过检查对象的内部属性（[[Class]]）来判断是否为数组，而不是依赖于原型链。\n1 2 console.log(Array.isArray([])); // true console.log(Array.isArray({})); // false constructor 属性 通过访问对象的 constructor 属性可以判断类型。\n1 2 3 4 5 console.log((123).constructor === Number); // true console.log(\u0026#39;hello\u0026#39;.constructor === String); // true console.log(true.constructor === Boolean); // true console.log([].constructor === Array); // true console.log({}.constructor === Object); // true 缺点：\n无法判断 null 和 undefined（它们没有 constructor 属性）。 可能会被重写。 ","date":"2025-01-09T13:23:00+08:00","permalink":"https://demo.stack.jimmycai.com/p/javascript-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/","title":"JavaScript 变量类型判断"},{"content":"变量 JavaScript 中的变量是松散的，它可以在初始化后再次改变类型。\nJavaScript 中的变量声明使用的关键字（var、let、const）也与常见编程语言不同，其作用不是指定其类型，而是限定其作用域。\nJavaScript 变量的类型由其值决定，变量值类型改变，变量类型随之改变。\n原始值和引用值 JavaScript 变量值分为原始值和引用值。\n原始值（primitive value）是最简单的数据，大小固定，保存在栈内存，有 6 中原始值类型：\nUndefined Null Boolean Number String Symbol 引用值是由多个值（既可以是原始值，也可以是引用值）组合成的对象，动态大小，引用值的地址值保存在栈内存，其指向的是该地址对应的保存在堆内存上的真实数据。\n字面量 字面量就是字面上的纯数据。\n原始值以及引用值的初始化既可以使用纯数据，也可以使用 new 执行对应类型的构造函数，通过后者得到的原始值就与对象的表现类似：\n1 2 3 4 5 6 let name = new String(\u0026#34;张三\u0026#34;); // 可以添加属性 person.age = 23; console.log(person.age); // 23 // typeof 返回 Object console.log(typeof name); // object 属性 原始值没有属性，也不能添加属性，引用值可以动态地添加、修改和删除属性。\n复制值 JavaScript中，原始值的复制就是复制其在栈内存上的值，引用值的复制实际上复制的是其位于栈内存的引用地址值。\n传递参数 ECMAScript 中所有参数都是按值传递的。这意味着中间存在变量的复制。\n形参与实参 形参是函数局部变量，实参是函数外部变量以及形参的来源。\n按值传递和按引用传递 从变量到数据，涉及到存储寻址，一个变量名对应一个地址，访问该地址获取到改地址的值，值可以为原始值或者另一个地址，地址值指示真正数据的位置。\n● 地址 1 -数据\n● 地址 1 -地址 2 -数据\n按值传递：形参、实参的地址 1 不同，但是地址 1 对应的数据或者地址 2 是相同的，这个也是按值所传递的东西。\n按引用传递：形参、实参地址 1 相同，所以后面寻址操作是一样的。\n1 2 3 4 5 6 7 8 function setName(obj) { obj.name = \u0026#34;Nicholas\u0026#34;; obj = new Object(); obj.name = \u0026#34;Greg\u0026#34;; } let person = new Object(); setName(person); console.log(person.name); // \u0026#34;Nicholas\u0026#34; 上述代码中，函数 setName 第二行重写了 obj，再修改 obj 无效，正是因为按值传递，重写 obj 是修改 obj 地址对应的数据，obj 这个形参与实参 person 的地址不同，重写 obj 不会导致 person 重写。\n变量类型判断 常见的类型判断方法是使用 typeof 和 instanceof。\ntypeof 适合判断一个变量是否是原始值。如果值是对象或 null，typeof 都会返回 null。使用 typeof 检测函数返回 function。\n对于对象，使用 instanceof 操作符。对于该对象原型链上的所有原型，instanceof 都返回 true。若对原始值使用 instanceof，则返回 false。\n变量声明 var 声明 在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在 with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文。\nvar声明（不包含赋值）会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前，这个现象叫作“提升”（hoisting）。 提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。\n1 2 3 4 5 6 7 8 console.log(a); // undefined，变量声明已提升，但赋值未提升 var a = 10; /** 等价于 **/ var a; console.log(a); // undefined a = 10; 函数声明也会被提升到作用域顶部，且整个函数体都会被提升。\n1 2 3 4 5 6 7 8 9 10 11 sayHello(); // \u0026#34;Hello!\u0026#34; function sayHello() { console.log(\u0026#34;Hello!\u0026#34;); } /** 等价于 **/ function sayHello() { console.log(\u0026#34;Hello!\u0026#34;); } sayHello(); // \u0026#34;Hello!\u0026#34; 函数的提升优先级高于 var 变量提升。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 console.log(foo); // ƒ foo() { return \u0026#34;function\u0026#34;; } var foo = \u0026#34;variable\u0026#34;; function foo() { return \u0026#34;function\u0026#34;; } console.log(foo); // \u0026#34;variable\u0026#34; /** 等价于 **/ function foo() { return \u0026#34;function\u0026#34;; } var foo; console.log(foo); // ƒ foo() { return \u0026#34;function\u0026#34;; } foo = \u0026#34;variable\u0026#34;; console.log(foo); // \u0026#34;variable\u0026#34; let 声明 ES6新增的let关键字跟var很相似，但它的作用域是块级的，这也是JavaScript中的新概念。块级作用域由最近的一对包含花括号{}界定。 换句话说，if块、while块、function块，甚至连单独的块也是let声明变量的作用域。\nlet 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError。\n严格来讲，let 在 JavaScript runtime 中也会被提升，但由于暂时性死区（temporal dead zone）的缘故， 实际上不能在声明之前使用 let 变量。因此，从写 JavaScript 代码的角度说，let 的提升跟 var 是不一样的。\nconst 声明 使用 const 声明的变量必须在声明时初始化，并且在其生命周期内不能重新赋值。除了这一点外，const 的行为与 let 相同。\nconst 声明的限制仅适用于变量的顶层值或引用。换句话说，如果一个 const 变量引用的是对象，则不能将该变量重新赋予新的引用值， 但对象本身的属性可以修改。如果需要让整个对象不可更改，可以使用 Object.freeze() 方法，这样对对象属性的修改不会报错，但会静默失败。\n由于 const 声明意味着变量的值是固定的且不可变，JavaScript 的运行时编译器可以将其优化为直接使用值，而无需通过变量查找。 所以在实际开发中，建议尽量使用 const 来声明变量。\n执行上下文与作用域 执行上下文 每当函数被调用、全局代码运行、或 eval 代码运行时，都会创建一个新的执行上下文，依此分为全局执行上下文、函数执行上下文、eval执行上下文。\n全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境表示全局上下文的对象可能不一样（如浏览器中的 window 或 Node.js 中的 global），使用 var 声明的顶级变量会被添加到该对象上，使用 let 或 const 声明的顶级变量则被添加到脚本（Script）作用域，但三者在作用域的表现上是一样的。\n函数调用时会创建函数上下文。函数执行时，函数的上下文会进入一个上下文栈，JavaScript 程序执行依靠的就是这个栈的控制。函数执行完后，其上下文会被弹出。\n变量或函数的上下文决定了它们的生命周期、可以访问哪些数据以及它们的行为，即它们的执行环境。\n每个上下文都关联一个变量对象（variable object, vo），而这个上下文中定义的所有变量和函数都存在于这个对象上。如果上下文是函数，则其活动对象（activation object）用作变量对象。对于全局作用域，变量对象是全局对象（例如浏览器中的 window）。上下文包含以下三个重要部分：\n变量环境：是词法环境的一种特殊情况，专门用于存储通过 var 声明的变量。 词法环境：包含当前上下文的标识符（变量、函数）以及对父级上下文的引用。let 和 const 是存储在词法环境中的，它们支持块级作用域，并具有 TDZ1 特性。 this 绑定：确定上下文中 this 的值，根据调用位置动态分配。 执行上下文是动态的，所以它拥有生命周期：\n创建阶段 变量对象初始化 作用域链创建 this 绑定 执行阶段 查找作用域链 销毁阶段 上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数。 作用域 Scope 作用域是变量和函数的可访问范围。它决定了代码中可以访问哪些变量。\n作用域分为全局作用域、函数作用域和块作用域。\n当前上下文的变量对象会与父级上下文的作用域链连接，形成一个作用域链。当访问一个变量时，JavaScript 引擎会沿着作用域链逐级向上查找，直到找到变量或到达全局作用域。上下文间是线性有序的，内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。\n函数的 [[Scopes]] 属性 函数的 [[Scopes]] 属性是 JavaScript 引擎内部用于实现作用域链的一个隐藏属性。它存储的是函数创建时的词法环境的引用，即是能够访问的所有外部作用域，是实现闭包的重要机制。这些作用域是按照作用域链的顺序排列的，最外层的作用域通常是全局作用域。\n查看 [[Scopes]] 属性 1.使用 debugger 断点调试\n1 2 3 4 5 6 7 8 9 10 11 12 function outer() { debugger; let outerVar = \u0026#34;I am outer\u0026#34;; function inner() { debugger; let innerVar = \u0026#34;I am inner\u0026#34;; console.log(outerVar); // 访问外部作用域的变量 } return inner; } let myInner = outer(); myInner(); 2.使用 console.dir()\n1 2 3 4 5 6 7 8 9 10 11 12 13 function outer() { let outerVar = \u0026#34;I am outer\u0026#34;; function inner() { let innerVar = \u0026#34;I am inner\u0026#34;; console.dir(arguments.callee); // 访问自身 console.log(outerVar); // 访问外部作用域的变量 } console.dir(arguments.callee); return inner; } let myInner = outer(); myInner(); console.dir(myInner); 执行上下文与作用域的关系 作用域在定义时确定（静态），执行上下文在运行时创建（动态）。 每个执行上下文都包含一个作用域链。 Temporal Dead Zone，暂时性死区，指变量只有声明后才能使用。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-01-06T12:34:00+08:00","permalink":"https://demo.stack.jimmycai.com/p/%E5%8F%98%E9%87%8F%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/","title":"变量、执行上下文与作用域"},{"content":"概念 防抖（Debounce）是指在事件触发后，只有在经过设定的时间间隔内没有再次触发，事件处理器才会执行。这样可以避免事件被频繁触发。\n节流（Throttling）则是指在一定时间间隔内，事件处理器只执行一次。这样可以控制事件的执行频率。\n实现 防抖实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function debounce(func, delay) { let timer; return function (...args) { clearTimeout(timer); // 清除之前的定时器 timer = setTimeout(() =\u0026gt; { func.apply(this, args); // 在延迟后执行回调 }, delay); }; } // 使用例子： const handleResize = debounce(() =\u0026gt; { console.log(\u0026#39;Window resized\u0026#39;); }, 300); window.addEventListener(\u0026#39;resize\u0026#39;, handleResize); 节流实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function throttle(func, delay) { let lastTime = 0; return function (...args) { const now = new Date().getTime(); if (now - lastTime \u0026gt;= delay) { lastTime = now; func.apply(this, args); // 在指定时间间隔内执行回调 } }; } // 使用例子： const handleScroll = throttle(() =\u0026gt; { console.log(\u0026#39;Scroll event triggered\u0026#39;); }, 200); window.addEventListener(\u0026#39;scroll\u0026#39;, handleScroll); 区别与相同点 防抖和节流都是针对频繁触发的事件，两次事件触发间隔（再次触发时间 now - 上次执行时间 lastTime）都大于等于一个指定值 delay， 区别在于防抖会不停重新计时，改变 lastTime，而节流则不会。\n使用场景 防抖防止事件被频繁触发，减少不必要的事件次数，合并事件，只有最后一次生效。常见应用场景：\n输入框搜索建议，用户停止输入后再发送请求； 调整窗口大小后重新计算布局； 表单验证，输入停止后再进行验证； 节流控制事件执行频率，一段时间内最多执行一次事件。常见应用场景：\n滚动事件，如懒加载图片； 页面点击操作统计； 高频按钮点击防止多次触发； 第三方函数实现 实际项目中，我们常常使用第三方工具库，其中也有库实现了防抖和节流，如 Lodash 和 Underscore（Lodash 的前身）。\nLodash 实现 Lodash 提供 _.debounce()、_.throttle() 分别实现防抖和节流。\n参数：\n1 2 3 4 5 6 7 8 9 import _ from \u0026#39;lodash\u0026#39;; const debounceFn = _.debounce(() =\u0026gt; { func() }, wait, option{?leading, ?trailing}); const throttleFn = _.throttle(() =\u0026gt; { func() }, wait, option{?leading, ?trailing}); func: 要防抖的函数。 wait: 延迟时间（毫秒）。 options: 可选配置对象： leading：是否在延迟开始前触发。 trailing：是否在延迟结束后触发。 ","date":"2025-01-06T12:05:00+08:00","permalink":"https://demo.stack.jimmycai.com/p/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","title":"防抖和节流"},{"content":" msconfig 打开系统配置 sysdm.cpl 打开系统属性 services.msc 打开服务 control 打开控制面板 explorer 打开资源管理器 gpedit.msc 打开本地组策略编辑器 lusrmgr.msc 打开本地用户和组 msinfo32 显示系统信息 mstsc 打开远程桌面连接 notepad 打开记事本 powercfg.cpl 打开电源选项 regedit.msc 打开注册表 slmgr.vbs -dlv 显示详细的许可证信息 taskmgr 打开任务管理器 ","date":"2025-01-06T10:01:00+08:00","permalink":"https://demo.stack.jimmycai.com/p/win--r-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"win + r 常用命令"},{"content":"设置代理 1 2 git config --global http.proxy http://your_proxy:port git config --global https.proxy http://your_proxy:port 验证设置 1 2 git config --global --get http.proxy git config --global --get https.proxy 取消代理 1 2 git config --global --unset http.proxy git config --global --unset https.proxy ","date":"2025-01-06T10:01:00+08:00","permalink":"https://demo.stack.jimmycai.com/p/%E9%85%8D%E7%BD%AE-git-%E4%BB%A3%E7%90%86/","title":"配置 Git 代理"},{"content":"Hugo 环境准备 安装 Git（必需） Windows 下载 Git for Windows 安装包。 按提示安装，默认设置即可。 安装完成后，打开命令行，验证安装：\n1 git --version macOS Linux 安装 Go（可选） Hugo 使用 Go 语言开发，但使用 Hugo 并不要求安装 Go，因为大多数用户直接下载 Hugo 的预编译二进制文件即可。 如果需要自行编译 Hugo 或使用 extended 版本，则需要安装 Go。\nGo is required to:\nBuild Hugo from source Use the Hugo Modules feature Windows 下载 Go 官方安装包。 按提示安装。 验证安装：\n1 go version macOS Linux 安装 Hugo Hugo is available in three editions: standard, extended, and extended/deploy.\n安装 Hugo 预编译二进制版本 下载 Hugo 二进制文件： 访问 Hugo Releases 页面。 下载适合的 .zip 文件（通常选择不带 extended 的版本，除非需要 SCSS 支持）。 解压文件，将 hugo.exe 添加到系统环境变量的 PATH 中。 测试是否安装成功：打开命令行，运行 hugo version。 通过包管理器 从源代码构建 创建 Hugo 站点 使用 Hugo 主题 一般使用 Hugo 主题的步骤为：\n1 2 3 4 5 # 使用 Git 克隆主题 git submodule add https://github.com/主题作者/主题仓库路径.git themes/主题名称 # 修改配置文件 config.toml，指定主题 theme = \u0026#34;主题名称\u0026#34; # 根据主题来进行个性化配置 有些主题也提供了快捷模板，如下。\nStack 主题 Documentation: https://stack.jimmycai.com/\nQuickStart：Use this template: CaiJimmy/hugo-theme-stack-starter\n开启评论 Hugo ships with support for Disqus, a third-party service that provides comment and community capabilities to websites via JavaScript.\nAlternative:\nwaline ","date":"2025-01-04T01:33:00+08:00","permalink":"https://demo.stack.jimmycai.com/p/hugo-%E5%85%A5%E9%97%A8/","title":"Hugo 入门"},{"content":"函数、极限与连续 数列极限 数列极限的定义 如果$\\forall\\varepsilon{\u0026gt;}0$,$\\exists N\\in\\mathbf{Z}^+$,当 $n\u0026gt;N$ 时,恒有$\\mid x_n-a\\mid{\u0026lt;}\\varepsilon$,则$\\lim\\limits_{n\\to{\\infty}}x_n{=}a.$\n数列的极限就是数列收敛的位置。\n任意的$\\varepsilon$ 刻画了$x_n$与$a$的接近程度，对应存在的$N$不是唯一的。从第$N+1$项开始到$\\infty$，后续项都位于$(a-\\varepsilon,a+\\varepsilon)$之间。这也就是说，数列的极限与前N项的变化无关，只与其发展趋势有关。\n定理(数列极限的运算法则) 若$\\lim\\limits_{n\\to\\infty}x_n=a,\\lim\\limits_{n\\to\\infty}y_n=b$，则\n$\\lim\\limits_{n\\to\\infty}(x_n\\pm y_n)=\\lim\\limits_{n\\to\\infty}x_n\\pm\\lim\\limits_{n\\to\\infty}y_n=a\\pm b$(加减法则) $\\lim\\limits_{n\\to\\infty}(x_n\\cdot y_n)=\\lim\\limits_{n\\to\\infty}x_n\\cdot\\lim\\limits_{n\\to\\infty}y_n=a\\cdot b$(乘法法则) $\\lim\\limits_{n\\to\\infty}\\sqrt{x_{n}}=\\sqrt{\\lim\\limits_{n\\to\\infty}x_{n}}=\\sqrt{a}\\left(x_{n}\\geqslant0,a\\geqslant0\\right)$(交换法则) $\\mathbf{\\lim\\limits_{n\\to\\infty}\\frac{x_n}{y_n}=\\frac{\\lim\\limits_{n\\to\\infty}x_n}{\\lim\\limits_{n\\to\\infty}y_n}=\\frac{a}{b}(\\lim\\limits_{n\\to\\infty}y_n=b\\neq0)}$(除法法则) 函数极限 自变量趋于无穷大的函数极限的定义 $\\text{如果 }\\forall\\varepsilon\u0026gt;0\\text{, }\\exists X\u0026gt;0\\text{,当}|x|\u0026gt;X\\text{ 时, 恒有}|f(x)-A|\u0026lt;\\varepsilon\\text{,则}\\lim\\limits_{x\\to\\infty}f(x)=A.$\n定理1 $\\lim\\limits_{x\\to\\infty}{f(x)} = A \\Leftrightarrow \\lim\\limits_{x\\to+\\infty}{f(x)} = A$且$\\lim\\limits_{x\\to-\\infty}{f(x)} = A$\n一般地，如果$\\lim\\limits_{x\\to+\\infty}f(x)=A$或$\\lim\\limits_{x\\to-\\infty}f(x)=A$，则称直线$y=A$为函数$y=f(x)$图形的水平渐近线。\n趋于一点时的函数极限的定义 $\\forall\\varepsilon\u0026gt;0,\\text{ }\\exists\\delta\u0026gt;0,\\text{ 当 }0\u0026lt;|x-x_0|\u0026lt;\\delta\\text{ 时, 恒有 }|f(x)-A|\u0026lt;\\varepsilon,\\text{那么}\\lim\\limits_{x\\to x_0}f(x)=A.$\n位于某个去心领域的自变量映射的因变量也位于某个领域内。\n显然有$\\lim\\limits_{x\\to x_{0}}f(x)=A{\\Leftrightarrow}f(x_{0}^{+})=f(x_{0}^{-})=A$。\n定理 2 (函数极限的四则运算法则) 设$\\lim\\limits_{x\\to x_0}{f(x)}=A,\\lim\\limits_{x\\to x_0}{g(x)}=B$\n$\\lim\\limits_{x\\to x_0}\\bigl[f(x)\\pm g(x)\\bigr]=A\\pm B=\\lim\\limits_{x\\to x_0}f(x)\\pm\\lim\\limits_{x\\to x_0}g(x);$ $\\lim\\limits_{x\\to x_0}[f(x)\\cdot g(x)]=A\\cdot B=\\lim\\limits_{x\\to x_0}f(x)\\cdot\\lim\\limits_{x\\to x_0}g(x);$ $\\lim\\limits_{x\\to x_{0}}\\frac{f(x)}{g(x)}=\\frac{A}{B}=\\frac{\\lim\\limits_{x\\to x_{0}}f(x)}{\\lim\\limits_{x\\to x_{0}}g(x)}(B\\neq0)$ 推论 若$\\underset{x\\to x_0}{\\operatorname*{lim}}f(x),\\underset{x\\to x_0}{\\lim\\limits}g(x)$存在，则\n$\\lim\\limits_{x\\to x_{0}}[\\alpha f(x)+\\beta g(x)]=\\alpha\\lim\\limits_{x\\to x_{0}}f(x)+\\beta\\lim\\limits_{x\\to x_{0}}g(x);$ $\\lim\\limits_{x\\to x_0}\\bigl[f(x)\\bigr]^n=\\bigl[\\lim\\limits_{x\\to x_0}f(x)\\bigr]^n(n\\in\\mathbf{Z}^+);$ $\\text{若}f(x)\\geqslant0,\\text{则}\\lim\\limits_{x\\to x_0}\\sqrt{f(x)}=\\sqrt{\\lim\\limits_{x\\to x_0}f(x)}$ $$ \\lim\\limits_{x\\to x_0}f\\bigl[g(x)\\bigr]=\\lim\\limits_{u\\to u_0}f\\bigl(u\\bigr)=A. $$$g(x)\\neq u_0$的作用是说明$f(u)$在$u_0$的去心领域里有定义。\n极限的性质 定理 1 (数列极限的唯一性) 数列$\\left{x_n\\right}$不能收敛于两个不同的极限.\n使用反证法结合数列极限的定义可证明。\n直观上看，由于$\\varepsilon$的任意性，数列的极限像是一个无穷小的领域，它包含了从N开始的后续项，如果数列收敛于两个不同极限，那么它们对应的N是一前一后，前者对应的领域应该包含后者。不会有两个不同的可以无限小的领域存在包含关系，所以就不会收敛于两个不同极限。\n数列${x_n}$有界是指$\\exists M\u0026gt;0$，使$\\forall x_n$满足$|x_n| \\leqslant M$.\n数列的有界和收敛是不同的，收敛描述数列的发展趋向，有界则指明数列的整体范围。数列${(-1)^n}$有界，但不收敛。\n定理 2 (收敛数列的有界性） 如果数列${x_n}$收敛，则该数列一定有界。\n设$x_n \\to a,\\forall \\varepsilon \u0026gt; 0,\\exists N \\in Z^+$,当$n \u0026gt; N$时,$|x_n| = |x_n - a + a| \\leqslant |x_n - a| + |a| \u0026lt; \\varepsilon + |a|$。取$M = max{|a_1|,|a_2|,···,|a_N|,\\varepsilon + |a|}$，那么$\\forall x_n,|x_n| \\leqslant M$。\n数列无界一定发散，数列有界不一定收敛。\n定理 3 (收敛级数的保号性) 如果$x_n \\to a(n \\to \\infty)$且$a \u0026gt; 0(或 a \u0026lt; 0)$，则存在$N \u0026gt; 0$，当$n \u0026gt; N$时，均有$x_n\u0026gt;0$(或$x_n \u0026lt; 0$)。\n$a - \\varepsilon \u0026lt; x_n \u0026lt; a + \\varepsilon$，$a \u0026gt; 0$时只要$\\varepsilon \u0026lt; a$即可保证$x_n \u0026gt; 0$，$a \u0026lt; 0$时只要$\\varepsilon \u0026lt; -a$即可保证$x_n \u0026lt; 0$。\n推论 如果${x_n}$满足：$\\exists N_1 \u0026gt; 0$，当$n \u0026gt; N_1$时，$x_n \\geqslant 0$(或$x_n \\leqslant 0$)，且$\\lim\\limits_{n \\to \\infty}{x_n} = a$，则$a \\geqslant 0$。\n在数列${x_n}$中任意抽取无限项并保持这些项在原数列中的先后次序，由此得到的一个新数列称为${x_n}$的子数列(子列)，记作${x_{n_k}}(n_k \\geqslant k)$。\n定理4 如果数列${x_n}$收敛于$a$，则它的子数列${x_{n_k}}$也收敛于$a$。\n由于数列${x_n}$收敛于$a$，则$\\forall \\varepsilon, \\exists N \\gt 0$，当$n \u0026gt; N$时，恒有$|x_n - a| \u0026lt; \\varepsilon$。\n当$k \u0026gt; N$时，$n_k \\gt n_N \\gt N$，有$|x_{n_k} - a| \\lt \\varepsilon$。\n故数列${x_{n_k}}$也收敛于$a$。\n由定理4推理可知，若数列的两个子数列收敛于不同的极限，那么该数列必定发散。\n且可证明：==若数列${x_n}$的奇数子数列${x_{2n+1}}$和偶数子数列${x_{2n}}$均收敛于$a$，则数列${x_n}$也收敛于$a$==。\n$\\forall \\varepsilon, \\exists N_1 \\gt 0$，当$odd \u0026gt; N_1$时，恒有$|x_{odd} - a| \u0026lt; \\varepsilon$\n$\\forall \\varepsilon, \\exists N_2 \\gt 0$，当$even \u0026gt; N_2$时，恒有$|x_{even} - a| \u0026lt; \\varepsilon$\n取$N=max{N_1,N_2}$时，当$n\u0026gt;N$时，恒有$|x_{n} - a| \u0026lt; \\varepsilon$，即数列${x_n}$也收敛于$a$。\n","date":"2024-02-03T00:00:00+08:00","permalink":"https://demo.stack.jimmycai.com/p/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD/","title":"函数、极限与连续"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"https://demo.stack.jimmycai.com/p/image-gallery/2_hu15576070775610481867.jpg","permalink":"https://demo.stack.jimmycai.com/p/image-gallery/","title":"Image gallery"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"https://demo.stack.jimmycai.com/p/shortcodes/cover_hu17063188895770243625.jpg","permalink":"https://demo.stack.jimmycai.com/p/shortcodes/","title":"Shortcodes"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ 1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ 1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/p/math-typesetting/","title":"Math Typesetting"},{"content":"Welcome to Hugo theme Stack. This is your first post. Edit or delete it, then start writing!\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2022-03-06T00:00:00Z","image":"https://demo.stack.jimmycai.com/p/hello-world/cover_hu6307248181568134095.jpg","permalink":"https://demo.stack.jimmycai.com/p/hello-world/","title":"Hello World"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/p/","title":""}]