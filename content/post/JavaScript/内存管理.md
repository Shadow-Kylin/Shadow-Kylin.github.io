---
title: JavaScript 内存管理
description: 
date: 2025-01-09 18:36:00+0800
image: 
categories:
    - Frontend
tags:
    - JavaScript
draft: 
hidden: 
math: 
weight:
slug:
license: true
---

# 自动垃圾回收

像 C 语言这样的低级语言拥有可手动管理内存的原语（primitive）—— malloc() 和 free()。而 JavaScript 有用于自动管理内存的垃圾回收机制（Garbage Collection, GC）。开发者无需手动分配和释放内存，当创建变量、对象或函数时，JavaScript 会自动分配内存，还会根据垃圾回收算法自动回收不再需要的对象的内存。

# 可达性与内存回收

JavaScript 使用可达性来判断一个对象是否需要被保留。根对象是默认可达的，比如全局对象（window）和当前作用域的变量。如果一个对象能通过根对象的引用链访问到，则该对象是可达的，不能被回收。

# 常见垃圾回收算法

## 标记-清理（Mark-and-Sweep）

这是最常见的垃圾回收算法，分为两个阶段：

- 标记阶段：从根对象出发，标记所有可达的对象。
- 清除阶段：清除没有被标记的对象，并回收它们所占的内存。

## 引用计数（Reference-counting）

每个对象有一个引用计数器，记录有多少引用指向它。如果对象的引用计数变为零，则认为该对象无法被访问，可以回收。

标记清理的痛点是无法处理循环引用，即两个或多个对象互相引用但从根不可达的情况，这也就会导致它们即使函数执行结束后内存得不到释放。

```javascript
function problem() {
	let objectA = new Object();
	let objectB = new Object();
	objectA.someOtherObject = objectB;
	objectB.anotherObject = objectA;
}
```

## 增量式垃圾回收

将垃圾回收过程拆分为多个小步骤，交替执行垃圾回收和程序执行，避免长时间的暂停。常用于现代 JavaScript 引擎中（如 V8 引擎）。

## 分代回收

将内存分为两代：

- 新生代：存储生命周期较短的对象（如临时变量）。
- 老生代：存储生命周期较长的对象（如全局变量）。

新生代对象会更频繁地进行垃圾回收，而老生代对象较少被回收。

# V8 引擎的垃圾回收

Google 的 V8 引擎（用于 Chrome 和 Node.js）结合了多种算法：

- 分代垃圾回收：将堆分为新生代和老生代。
- Scavenge 算法（新生代）：将活动对象复制到新空间并清空旧空间。
- 标记-清除和标记-压缩算法（老生代）：用于回收生命周期长的对象。
- 并行和增量回收：提高垃圾回收的性能，减少主线程的停顿。

# 内存优化

1. 尽量避免使用全局变量，因为全局变量生命周期长，不易被回收。
2. 及时清理无用引用，避免内存泄漏，可以手动设置对象为 null，帮助垃圾回收器识别。主要注意意外的全局变量、闭包和计时器中的引用。
3. 在使用闭包或 DOM 事件时，避免产生循环引用。
4. 使用 let 或 const 声明变量可以缩小作用域，尽早回收可以回收的内存。
5. 共享隐藏类，避免 JavaScript 中的先创建再补充（ready-fire-aim）式的动态属性赋值，并在构造函数中一次性声明所有可能需要的属性。如果不再需要一个属性值要删除它，可以设其为 null 解除引用，而非直接删除。
6. 使用静态分配的对象池，减少浏览器执行垃圾回收的次数。

